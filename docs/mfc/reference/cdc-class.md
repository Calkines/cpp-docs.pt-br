---
title: Classe CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: fc5d41221ab0f9679e7d38a399464efc1a38dd52
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62173532"
---
# <a name="cdc-class"></a>Classe CDC

Define uma classe de objetos de contexto de dispositivo.

## <a name="syntax"></a>Sintaxe

```
class CDC : public CObject
```

## <a name="members"></a>Membros

### <a name="public-constructors"></a>Construtores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::CDC](#cdc)|Constrói um objeto `CDC`.|

### <a name="public-methods"></a>Métodos públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Encerra o trabalho de impressão atual, Apagar tudo o que o aplicativo escrito para o dispositivo desde a última chamada da `StartDoc` função de membro.|
|[CDC::AbortPath](#abortpath)|Fecha e descarta todos os caminhos no contexto de dispositivo.|
|[CDC::AddMetaFileComment](#addmetafilecomment)|Copia o comentário de um buffer em um metarquivo aprimorado de formato especificado.|
|[CDC::AlphaBlend](#alphablend)|Exibe os bitmaps que possuem pixels transparentes ou semitransparentes.|
|[CDC::AngleArc](#anglearc)|Desenha um segmento de linha e um arco e move a posição atual para o ponto final do arco.|
|[CDC::Arc](#arc)|Desenha um arco elíptico.|
|[CDC::ArcTo](#arcto)|Desenha um arco elíptico. Essa função é semelhante ao `Arc`, exceto que a posição atual é atualizada.|
|[CDC::Attach](#attach)|Anexa um contexto de dispositivo do Windows a esta `CDC` objeto.|
|[CDC::BeginPath](#beginpath)|Abre um colchete de caminho no contexto de dispositivo.|
|[CDC::BitBlt](#bitblt)|Copia um bitmap de um contexto de dispositivo especificado.|
|[CDC::Chord](#chord)|Desenha uma corda (uma figura fechada limitada pela interseção de uma elipse e um segmento de linha).|
|[CDC::CloseFigure](#closefigure)|Fecha uma figura aberta em um caminho.|
|[CDC::CreateCompatibleDC](#createcompatibledc)|Cria um contexto de dispositivo de memória que é compatível com o outro contexto de dispositivo. Você pode usá-lo para preparar imagens na memória.|
|[CDC::CreateDC](#createdc)|Cria um contexto de dispositivo para um dispositivo específico.|
|[CDC::CreateIC](#createic)|Cria um contexto de informações de um dispositivo específico. Isso fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.|
|[CDC::DeleteDC](#deletedc)|Exclui o contexto de dispositivo do Windows associado a este `CDC` objeto.|
|[CDC::DeleteTempMap](#deletetempmap)|Chamado pelo `CWinApp` manipulador de tempo ocioso para excluir qualquer temporário `CDC` objeto criado pelo `FromHandle`. Também desanexa o contexto de dispositivo.|
|[CDC::Detach](#detach)|Desanexa o contexto de dispositivo do Windows deste `CDC` objeto.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Converte as unidades de dispositivo em unidades HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Converte as unidades de dispositivo em unidades lógicas.|
|[CDC::Draw3dRect](#draw3drect)|Desenha um retângulo tridimensional.|
|[CDC::DrawDragRect](#drawdragrect)|Apaga e redesenhar um retângulo conforme ela é arrastada.|
|[CDC::DrawEdge](#drawedge)|Desenha as bordas de um retângulo.|
|[CDC::DrawEscape](#drawescape)|Acessos a recursos que não estão diretamente disponíveis por meio da interface de dispositivo de gráficos (GDI) de um monitor de vídeo de desenho.|
|[CDC::DrawFocusRect](#drawfocusrect)|Desenha um retângulo no estilo usado para indicar o foco.|
|[CDC::DrawFrameControl](#drawframecontrol)|Desenhe um controle de quadro.|
|[CDC::DrawIcon](#drawicon)|Desenha um ícone.|
|[CDC::DrawState](#drawstate)|Exibe uma imagem e aplica um efeito visual para indicar um estado.|
|[CDC::DrawText](#drawtext)|Desenha o texto no retângulo especificado de formatado.|
|[CDC::DrawTextEx](#drawtextex)|Desenha o texto no retângulo especificado usando formatos adicionais de formatado.|
|[CDC::Ellipse](#ellipse)|Desenha uma elipse.|
|[CDC::EndDoc](#enddoc)|Termina um trabalho de impressão iniciado pela `StartDoc` função de membro.|
|[CDC::EndPage](#endpage)|Informa o driver de dispositivo que uma página está terminando.|
|[CDC::EndPath](#endpath)|Fecha um colchete de caminho e seleciona o caminho definido pelo suporte para o contexto de dispositivo.|
|[CDC::EnumObjects](#enumobjects)|Enumera as canetas e pincéis disponíveis em um contexto de dispositivo.|
|[CDC::Escape](#escape)|Permite que aplicativos acessem os recursos que não estão disponíveis diretamente de um determinado dispositivo através de GDI. Também permite o acesso às funções de escape do Windows. Chamadas de escape feitas por um aplicativo sejam convertidas e enviadas para o driver de dispositivo.|
|[CDC::ExcludeClipRect](#excludecliprect)|Cria uma nova região de recorte que consiste de recorte existente menos o retângulo especificado.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Impede que o desenho nas áreas inválidos de uma janela com a exclusão de uma região atualizada na janela de uma região de recorte.|
|[CDC::ExtFloodFill](#extfloodfill)|Preenche uma área com o pincel atual. Fornece mais flexibilidade do que o [CDC::FloodFill](#floodfill) função de membro.|
|[CDC::ExtTextOut](#exttextout)|Grava uma cadeia de caracteres dentro de uma região retangular usando a fonte atualmente selecionada.|
|[CDC::FillPath](#fillpath)|Fecha as figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de preenchimento de polígono.|
|[CDC::FillRect](#fillrect)|Preenche um retângulo determinado, usando um pincel específico.|
|[CDC::FillRgn](#fillrgn)|Preenche uma região específica com o pincel especificado.|
|[CDC::FillSolidRect](#fillsolidrect)|Preenche um retângulo com uma cor sólida.|
|[CDC::FlattenPath](#flattenpath)|Transforma qualquer curvas no caminho selecionado no contexto de dispositivo atual e transforma cada curva em uma sequência de linhas.|
|[CDC::FloodFill](#floodfill)|Preenche uma área com o pincel atual.|
|[CDC::FrameRect](#framerect)|Desenha uma borda em torno de um retângulo.|
|[CDC::FrameRgn](#framergn)|Desenha uma borda em torno de uma região específica usando um pincel.|
|[CDC::FromHandle](#fromhandle)|Retorna um ponteiro para um `CDC` quando é fornecido um identificador para um contexto de dispositivo do objeto. Se um `CDC` objeto não está anexado ao identificador, um temporário `CDC` objeto é criado e anexado.|
|[CDC::GetArcDirection](#getarcdirection)|Retorna a direção do arco atual para o contexto de dispositivo.|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|Recupera a configuração para o filtro de taxa de proporção atual.|
|[CDC::GetBkColor](#getbkcolor)|Recupera a cor de plano de fundo atual.|
|[CDC::GetBkMode](#getbkmode)|Recupera o modo de tela de fundo.|
|[CDC::GetBoundsRect](#getboundsrect)|Retorna o retângulo delimitador acumulado atual para o contexto de dispositivo especificado.|
|[CDC::GetBrushOrg](#getbrushorg)|Recupera a origem do pincel atual.|
|[CDC::GetCharABCWidths](#getcharabcwidths)|Recupera as larguras, em unidades lógicas, de caracteres consecutivos em um determinado intervalo da fonte atual.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Recupera as larguras, em unidades lógicas, consecutivos de índices de glifo em um intervalo especificado de fonte TrueType atual.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Recupera vários tipos de informações em uma cadeia de caracteres.|
|[CDC::GetCharWidth](#getcharwidth)|Recupera as larguras de caracteres consecutivos em um determinado intervalo de fracionárias da fonte atual.|
|[CDC::GetCharWidthI](#getcharwidthi)|Recupera as larguras, em coordenadas lógicas, consecutivos de índices de glifo em um intervalo especificado da fonte atual.|
|[CDC::GetClipBox](#getclipbox)|Recupera as dimensões do retângulo delimitador tightest em torno do limite de recorte atual.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Recupera os valores de ajuste de cor para o contexto de dispositivo.|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|Retorna um ponteiro para selecionado no momento `CBitmap` objeto.|
|[CDC::GetCurrentBrush](#getcurrentbrush)|Retorna um ponteiro para selecionado no momento `CBrush` objeto.|
|[CDC::GetCurrentFont](#getcurrentfont)|Retorna um ponteiro para selecionado no momento `CFont` objeto.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Retorna um ponteiro para selecionado no momento `CPalette` objeto.|
|[CDC::GetCurrentPen](#getcurrentpen)|Retorna um ponteiro para selecionado no momento `CPen` objeto.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Recupera a posição atual da caneta (em coordenadas lógicas).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Recupera a cor atual do pincel.|
|[CDC::GetDCPenColor](#getdcpencolor)|Recupera a cor atual da caneta.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Recupera um tipo especificado de informações específicas do dispositivo sobre recursos do dispositivo de uma exibição em questão.|
|[CDC::GetFontData](#getfontdata)|Recupera informações de métrica de fonte de um arquivo de fonte escalonável. As informações a serem recuperadas são identificadas, especificando um deslocamento para o arquivo de fonte e o tamanho das informações para retornar.|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|Retorna informações sobre a fonte atualmente selecionada para o contexto de exibição especificado.|
|[CDC::GetGlyphOutline](#getglyphoutline)|Recupera a curva de estrutura de tópicos ou de bitmap para um caractere de estrutura de tópicos na fonte atual.|
|[CDC::GetGraphicsMode](#getgraphicsmode)|Recupera o modo de gráfico atual para o contexto de dispositivo especificado.|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|Recupera um pincel de meio-tom.|
|[CDC::GetKerningPairs](#getkerningpairs)|Recupera o caractere kerning de pares para a fonte atualmente selecionada no contexto de dispositivo especificado.|
|[CDC::GetLayout](#getlayout)|Recupera o layout de um contexto de dispositivo (DC). O layout pode ser deixado tanto para a direita (padrão) ou da direita para esquerda (espelhado).|
|[CDC::GetMapMode](#getmapmode)|Recupera o modo de mapeamento atual.|
|[CDC::GetMiterLimit](#getmiterlimit)|Retorna o limite de Malhete para o contexto de dispositivo.|
|[CDC::GetNearestColor](#getnearestcolor)|Recupera a cor mais próxima lógica para uma cor especificada lógica que determinado dispositivo pode representar.|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|Recupera informações de métrica de fonte para as fontes TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Recupera as larguras de caracteres individuais em um grupo de caracteres consecutivos da fonte atual usando o contexto de dispositivo de saída.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Calcula a largura e altura de uma cadeia de caracteres no contexto de dispositivo de saída.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Calcula a largura e altura de uma linha de texto no contexto de dispositivo de saída usando a fonte atual para determinar as dimensões.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Recupera as métricas para a fonte atual do contexto do dispositivo de saída.|
|[CDC::GetPath](#getpath)|Recupera as coordenadas definindo os pontos de extremidade de linhas e pontos de controle de curvas encontrados no caminho que está selecionado no contexto de dispositivo.|
|[CDC::GetPixel](#getpixel)|Recupera o valor de cor RGB do pixel no ponto especificado.|
|[CDC::GetPolyFillMode](#getpolyfillmode)|Recupera o modo de preenchimento de polígono atual.|
|[CDC::GetROP2](#getrop2)|Recupera o modo de desenho atual.|
|[CDC::GetSafeHdc](#getsafehdc)|Retorna [CDC::m_hDC](#m_hdc), o contexto de dispositivo de saída.|
|[CDC::GetStretchBltMode](#getstretchbltmode)|Recupera o modo atual de alongamento de bitmap.|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|Calcula a largura e altura de uma cadeia de caracteres no contexto de dispositivo do atributo.|
|[CDC::GetTextAlign](#gettextalign)|Recupera os sinalizadores de alinhamento de texto.|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|Recupera a configuração atual para a quantidade de espaçamento intercharacter.|
|[CDC::GetTextColor](#gettextcolor)|Recupera a cor do texto atual.|
|[CDC::GetTextExtent](#gettextextent)|Calcula a largura e altura de uma linha de texto no contexto de dispositivo de atributo usando a fonte atual para determinar as dimensões.|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|Recupera o número de caracteres em uma cadeia de caracteres especificada que caiba dentro de um espaço especificado e preenche uma matriz com a extensão do texto para cada um desses caracteres.|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|Recupera a largura e altura da matriz especificada de índices de glifo.|
|[CDC::GetTextFace](#gettextface)|Copia o nome da face da fonte atual em um buffer como uma cadeia de caracteres terminada em nulo.|
|[CDC::GetTextMetrics](#gettextmetrics)|Recupera as métricas para a fonte atual do contexto do dispositivo de atributo.|
|[CDC::GetViewportExt](#getviewportext)|Recupera as extensões x e y do visor.|
|[CDC::GetViewportOrg](#getviewportorg)|Recupera as coordenadas x e y da origem do visor.|
|[CDC::GetWindow](#getwindow)|Retorna a janela associada ao contexto de dispositivo de exibição.|
|[CDC::GetWindowExt](#getwindowext)|Recupera as extensões x e y da janela associada.|
|[CDC::GetWindowOrg](#getwindoworg)|Recupera as coordenadas x e y da origem da janela associada.|
|[CDC::GetWorldTransform](#getworldtransform)|Recupera o espaço de mundo atual para transformação de espaço da página.|
|[CDC::GradientFill](#gradientfill)|Preenche o retângulo e triângulo estruturas com uma cor gradating.|
|[CDC::GrayString](#graystring)|Desenha esmaecido texto (cinza) no local especificado.|
|[CDC::HIMETRICtoDP](#himetrictodp)|Converte unidades HIMETRIC em unidades de dispositivo.|
|[CDC::HIMETRICtoLP](#himetrictolp)|Converte unidades HIMETRIC em unidades lógicas.|
|[CDC::IntersectClipRect](#intersectcliprect)|Cria uma nova região de recorte, formando a interseção da região atual e um retângulo.|
|[CDC::InvertRect](#invertrect)|Inverte o conteúdo de um retângulo.|
|[CDC::InvertRgn](#invertrgn)|Inverte as cores em uma região.|
|[CDC::IsPrinting](#isprinting)|Determina se o contexto de dispositivo está sendo usado para impressão.|
|[CDC::LineTo](#lineto)|Desenha uma linha da posição atual até, mas não incluindo, um ponto.|
|[CDC::LPtoDP](#lptodp)|Converte as unidades lógicas em unidades de dispositivo.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Converte unidades lógicas em unidades HIMETRIC.|
|[CDC::MaskBlt](#maskblt)|Combina os dados de cor para bitmaps de origem e de destino usando a máscara de determinada e a operação de varredura.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Altera a transformação global para um contexto de dispositivo usando o modo especificado.|
|[CDC::MoveTo](#moveto)|Move a posição atual.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Move a região de recorte de determinado dispositivo.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Modifica a origem do visor em relação as coordenadas da origem visor atual.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Modifica a origem de janela em relação as coordenadas da origem da janela atual.|
|[CDC::PaintRgn](#paintrgn)|Preenche uma região com o pincel selecionado.|
|[CDC::PatBlt](#patblt)|Cria um padrão de bit.|
|[CDC::Pie](#pie)|Desenha uma borda em forma de pizza.|
|[CDC::PlayMetaFile](#playmetafile)|Reproduz o conteúdo do metarquivo especificado em determinado dispositivo. A versão aprimorada do `PlayMetaFile` exibe a imagem armazenada no metarquivo aprimorado de formato fornecido. O metarquivo pode ser executado qualquer número de vezes.|
|[CDC::PlgBlt](#plgblt)|Executa uma transferência de bloco de bits dos bits de dados de cor do retângulo especificado no contexto de dispositivo de origem para o paralelogramo especificado no contexto de determinado dispositivo.|
|[CDC::PolyBezier](#polybezier)|Desenha uma ou mais splines de Bzier. A posição atual não é usada nem atualizada.|
|[CDC::PolyBezierTo](#polybezierto)|Desenha uma ou mais splines de Bzier e move a posição atual para o ponto final da última Bzier spline.|
|[CDC::PolyDraw](#polydraw)|Desenha um conjunto de segmentos de linha e splines Bzier. Essa função atualiza a posição atual.|
|[CDC::Polygon](#polygon)|Desenha um polígono que consiste em dois ou mais pontos (vértices) conectados por linhas.|
|[CDC::Polyline](#polyline)|Desenha um conjunto de segmentos de linha que conecta os pontos especificados.|
|[CDC::PolylineTo](#polylineto)|Desenha uma ou mais linhas retas e move a posição atual para o ponto final da última linha.|
|[CDC::PolyPolygon](#polypolygon)|Cria duas ou mais polígonos que são preenchidos usando o modo de preenchimento de polígono atual. Os polígonos podem ser contíguos ou eles podem se sobrepor.|
|[CDC::PolyPolyline](#polypolyline)|Desenha a várias séries de segmentos de linha conectados. A posição atual não é usada nem atualizada por essa função.|
|[CDC::PtVisible](#ptvisible)|Especifica se o determinado ponto está dentro da região de recorte.|
|[CDC::RealizePalette](#realizepalette)|Mapeia entradas da paleta na paleta lógica atual para a paleta do sistema.|
|[CDC::Rectangle](#rectangle)|Desenha um retângulo usando a caneta atual e preenche-o usando o pincel atual.|
|[CDC::RectVisible](#rectvisible)|Determina se qualquer parte do retângulo especificado está dentro da região de recorte.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Versões `m_hAttribDC`, o contexto de dispositivo do atributo.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Versões `m_hDC`, o contexto de dispositivo de saída.|
|[CDC::ResetDC](#resetdc)|Atualizações de `m_hAttribDC` contexto de dispositivo.|
|[CDC::RestoreDC](#restoredc)|Restaura o contexto de dispositivo para um estado anterior salvo com `SaveDC`.|
|[CDC::RoundRect](#roundrect)|Desenha um retângulo com cantos arredondados, usando a caneta atual e preenchido usando o pincel atual.|
|[CDC::SaveDC](#savedc)|Salva o estado atual do contexto do dispositivo.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Modifica a extensão do visor em relação aos valores atuais.|
|[CDC::ScaleWindowExt](#scalewindowext)|Modifica as extensões de janela em relação aos valores atuais.|
|[CDC::ScrollDC](#scrolldc)|Rola um retângulo de bits horizontalmente e verticalmente.|
|[CDC::SelectClipPath](#selectclippath)|Seleciona o caminho atual como uma região de recorte para o contexto de dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.|
|[CDC::SelectClipRgn](#selectcliprgn)|Combina a determinada região com a região de recorte atual usando o modo especificado.|
|[CDC::SelectObject](#selectobject)|Seleciona um objeto de desenho GDI, como uma caneta.|
|[CDC::SelectPalette](#selectpalette)|Seleciona a paleta lógica.|
|[CDC::SelectStockObject](#selectstockobject)|Seleciona uma do pincéis, canetas de ações predefinidas ou fontes fornecidas pelo Windows.|
|[CDC::SetAbortProc](#setabortproc)|Define uma função de retorno de chamada fornecido pelo programador do Windows chama se um trabalho de impressão deve ser anulado.|
|[CDC::SetArcDirection](#setarcdirection)|Define a direção de desenho a ser usado para funções de arco e retângulo.|
|[CDC::SetAttribDC](#setattribdc)|Conjuntos de `m_hAttribDC`, o contexto de dispositivo do atributo.|
|[CDC::SetBkColor](#setbkcolor)|Define a cor de plano de fundo atual.|
|[CDC::SetBkMode](#setbkmode)|Define o modo de tela de fundo.|
|[CDC::SetBoundsRect](#setboundsrect)|Controla o acúmulo de informações do retângulo delimitador para o contexto de dispositivo especificado.|
|[CDC::SetBrushOrg](#setbrushorg)|Especifica a origem para o próximo pincel selecionado em um contexto de dispositivo.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Define os valores de ajuste de cor para o contexto de dispositivo usando os valores especificados.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Define a cor do pincel atual.|
|[CDC::SetDCPenColor](#setdcpencolor)|Define a cor da caneta atual.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Define o modo de gráfico atual para o contexto de dispositivo especificado.|
|[CDC::SetLayout](#setlayout)|Altera o layout de um contexto de dispositivo (DC).|
|[CDC::SetMapMode](#setmapmode)|Define o modo de mapeamento atual.|
|[CDC::SetMapperFlags](#setmapperflags)|Altera o algoritmo que o mapeador de fonte usa quando ele mapeia lógicas fontes para fontes físicas.|
|[CDC::SetMiterLimit](#setmiterlimit)|Define o limite para o comprimento de esquadrias para o contexto de dispositivo.|
|[CDC::SetOutputDC](#setoutputdc)|Conjuntos de `m_hDC`, o contexto de dispositivo de saída.|
|[CDC::SetPixel](#setpixel)|Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada.|
|[CDC::SetPixelV](#setpixelv)|Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. `SetPixelV` é mais rápido que `SetPixel` porque ele não precisa retornar o valor de cor do ponto em que realmente é pintado.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Define o modo de preenchimento de polígono.|
|[CDC::SetROP2](#setrop2)|Define o modo de desenho atual.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Define o modo de alongamento de bitmap.|
|[CDC::SetTextAlign](#settextalign)|Define os sinalizadores de alinhamento de texto.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Define a quantidade de espaçamento intercharacter.|
|[CDC::SetTextColor](#settextcolor)|Define a cor do texto.|
|[CDC::SetTextJustification](#settextjustification)|Adiciona um espaço para os caracteres de quebra em uma cadeia de caracteres.|
|[CDC::SetViewportExt](#setviewportext)|Define as extensões x e y do visor.|
|[CDC::SetViewportOrg](#setviewportorg)|Define a origem do visor.|
|[CDC::SetWindowExt](#setwindowext)|Define as extensões x e y da janela associada.|
|[CDC::SetWindowOrg](#setwindoworg)|Define a origem da janela do contexto do dispositivo.|
|[CDC::SetWorldTransform](#setworldtransform)|Define o espaço de mundo atual para transformação de espaço da página.|
|[CDC::StartDoc](#startdoc)|Informa o driver de dispositivo que um novo trabalho de impressão está sendo iniciado.|
|[CDC::StartPage](#startpage)|Informa o driver de dispositivo que está iniciando uma nova página.|
|[CDC::StretchBlt](#stretchblt)|Move um bitmap de um retângulo de origem e um dispositivo em um retângulo de destino, alongando-o ou compactando-o se necessário, para se ajustar às dimensões do retângulo de destino.|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|Fecha as figuras abertas em um caminho, atinge o contorno do caminho usando a caneta atual e preenche o interior usando o pincel atual.|
|[CDC::StrokePath](#strokepath)|Renderiza o caminho especificado usando a caneta atual.|
|[CDC::TabbedTextOut](#tabbedtextout)|Grava uma cadeia de caracteres em um local especificado, a expansão de guias para os valores especificados em uma matriz de posições de parada de tabulação.|
|[CDC::TextOut](#textout)|Grava uma cadeia de caracteres em um local especificado usando a fonte atualmente selecionada.|
|[CDC::TransparentBlt](#transparentblt)|Transfere um bloco de bits de dados de cor do contexto do dispositivo de origem especificado em um contexto de dispositivo de destino, renderização de uma cor especificada transparente na transferência.|
|[CDC::UpdateColors](#updatecolors)|Atualizações de área de cliente do contexto do dispositivo combinando atual cores na área de cliente para a paleta do sistema em uma base de pixel por pixel.|
|[CDC::WidenPath](#widenpath)|Redefine o caminho atual como a área que deve ser pintada se o caminho foram traçado usando a caneta selecionada atualmente no contexto de dispositivo.|

### <a name="public-operators"></a>Operadores públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::Operator HDC](#operator_hdc)|Recupera o identificador do contexto do dispositivo.|

### <a name="public-data-members"></a>Membros de Dados Públicos

|Nome|Descrição|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|O contexto de dispositivo do atributo usado por este `CDC` objeto.|
|[CDC::m_hDC](#m_hdc)|O contexto de dispositivo de saída usado por este `CDC` objeto.|

## <a name="remarks"></a>Comentários

O `CDC` objeto fornece funções de membro para trabalhar com um contexto de dispositivo, como uma exibição ou impressora, bem como os membros para trabalhar com um contexto de exibição associado com a área de cliente de uma janela.

Fazer todos os desenhos por meio do membro de funções de um `CDC` objeto. A classe fornece funções de membro para operações de contexto de dispositivo, trabalhando com ferramentas, seleção de objetos de interface (GDI) de dispositivo de gráficos fortemente tipado, de desenho e trabalhar com cores e paletas. Ele também fornece funções de membro para obter e definir atributos, mapeamento, trabalhando com o visor, trabalhando com a extensão de janela, convertendo de coordenadas, trabalhando com regiões de recorte, desenhar linhas e formas de desenho simples, elipses, de desenho e polígonos. Funções de membro também são fornecidas para desenho de texto, trabalhar com fontes, usando o escape de impressora, rolagem e reproduzindo metarquivos.

Para usar um `CDC` do objeto, construí-lo e, em seguida, chamar seus membros de funções que funções do Windows que usar contextos de dispositivo em paralelo.

> [!NOTE]
>  No Windows 95/98, todas as coordenadas de tela são limitadas a 16 bits. Portanto, uma **int** passado para um `CDC` função de membro deve estar no intervalo de -32768 a 32767.

Para usos específicos, a biblioteca Microsoft Foundation Class fornece várias classes derivadas de `CDC` . `CPaintDC` encapsula chamadas para `BeginPaint` e `EndPaint`. `CClientDC` gerencia um contexto de exibição associado a uma área da janela cliente. `CWindowDC` gerencia um contexto de exibição associado a uma janela inteira, incluindo seu quadro e controles. `CMetaFileDC` associa um contexto de dispositivo com um metarquivo.

`CDC` fornece duas funções de membro [GetLayout](#getlayout) e [SetLayout](#setlayout), para a reversão do layout de um contexto de dispositivo que não herda seu layout de uma janela. Essa orientação da direita para esquerda é necessária para aplicativos escritos para culturas, como árabe ou hebraico, onde o layout de caractere não é o padrão europeu.

`CDC` contém dois contextos de dispositivo [m_hDC](#m_hdc) e [m_hAttribDC](#m_hattribdc), que, a criação de um `CDC` de objeto, se referem ao mesmo dispositivo. `CDC` direciona todas as chamadas de saída GDI para `m_hDC` e a maioria dos atributos GDI chamadas para `m_hAttribDC`. (É um exemplo de uma chamada de atributo `GetTextColor`, enquanto `SetTextColor` é uma chamada de saída.)

Por exemplo, a estrutura usa esses contextos de dispositivo de duas para implementar um `CMetaFileDC` objeto que envia saída para um metarquivo ao ler os atributos de um dispositivo físico. Visualização de impressão é implementada no framework de maneira semelhante. Você também pode usar os contextos de dois dispositivo de maneira semelhante em seu código específico do aplicativo.

Há vezes quando podem precisar de informações de métrica de texto de ambos os `m_hDC` e `m_hAttribDC` contextos de dispositivo. Os seguintes pares de funções fornecem essa funcionalidade:

|Usa m_hAttribDC|Uses m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Para obter mais informações sobre `CDC`, consulte [contextos de dispositivo](../../mfc/device-contexts.md).

## <a name="inheritance-hierarchy"></a>Hierarquia de herança

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Requisitos

**Cabeçalho:** afxwin. h

##  <a name="abortdoc"></a>  CDC::AbortDoc

Encerra o trabalho de impressão atual e Apaga tudo o que o aplicativo escrito para o dispositivo desde a última chamada para o [StartDoc](#startdoc) função de membro.

```
int AbortDoc();
```

### <a name="return-value"></a>Valor de retorno

Um valor maior que ou igual a 0 se for bem-sucedido, ou um valor negativo se ocorreu um erro. A lista a seguir mostra os valores de erro comuns e seus significados:

- Erro geral de SP_ERROR.

- Não SP_OUTOFDISK espaço em disco suficiente está disponível atualmente para o spool e não há mais espaço se tornará disponível.

- SP_OUTOFMEMORY não há memória suficiente está disponível para o spool.

- O usuário de SP_USERABORT concluiu o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Essa função membro substitui o escape de impressora ABORTDOC.

`AbortDoc` deve ser usada para encerrar o seguinte:

- Operações de impressão que não especificam uma função de anulação usando [SetAbortProc](#setabortproc).

- Operações de impressão que ainda não atingiram suas NEWFRAME primeiro ou NEXTBAND chamada de escape.

Se um aplicativo encontra um erro de impressão ou uma operação de impressão cancelada, ele não deve tentar encerrar a operação usando o [EndDoc](#enddoc) ou `AbortDoc` funções de membro da classe `CDC`. GDI automaticamente encerra a operação antes de retornar o valor de erro.

Se o aplicativo exibe uma caixa de diálogo para permitir que o usuário cancelar a operação de impressão, ela deve chamar `AbortDoc` antes de destruir a caixa de diálogo.

Se o Gerenciador de impressão foi usado para iniciar o trabalho de impressão, chamando `AbortDoc` apaga o trabalho de spool todo — a impressora recebe nada. Se o Gerenciador de impressão não foi usado para iniciar o trabalho de impressão, os dados talvez tenha sido enviados para a impressora antes de `AbortDoc` foi chamado. Nesse caso, o driver de impressora redefiniria a impressora (quando possível) e fechado o trabalho de impressão.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::StartDoc](#startdoc).

##  <a name="abortpath"></a>  CDC::AbortPath

Fecha e descarta todos os caminhos no contexto de dispositivo.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se houver um colchete de caminho aberto no contexto de dispositivo, o suporte do caminho é fechado e o caminho é descartado. Se houver um caminho fechado no contexto de dispositivo, o caminho é descartado.

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

Copia o comentário de um buffer em um metarquivo aprimorado de formato especificado.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Parâmetros

*nDataSize*<br/>
Especifica o comprimento do buffer de comentário, em bytes.

*pCommentData*<br/>
Aponta para o buffer que contém o comentário.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um comentário pode incluir qualquer informação particular — por exemplo, a origem da imagem e a data ele foi criado. Um comentário deve começar com uma assinatura do aplicativo, seguida dos dados. Comentários não devem conter dados específicos de posição. Dados específicos de posição especificam o local de um registro, e não deve ser incluído porque um metarquivo pode ser inserido em outro metarquivo. Essa função só pode ser usada com metarquivos.

##  <a name="alphablend"></a>  CDC::AlphaBlend

Chame essa função de membro para exibir os bitmaps que possuem pixels transparentes ou semitransparentes.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Um ponteiro para o contexto de dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*blend*<br/>
Especifica um [BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction) estrutura.

### <a name="return-value"></a>Valor de retorno

VERDADEIRO se bem-sucedido; Caso contrário, FALSE.

### <a name="remarks"></a>Comentários

Ver [AlphaBlend](/windows/desktop/api/wingdi/nf-wingdi-alphablend) no SDK do Windows para obter mais informações.

##  <a name="anglearc"></a>  CDC::AngleArc

Desenha um arco e um segmento de linha.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do centro do círculo.

*y*<br/>
Especifica a coordenada y lógica do centro do círculo.

*nRadius*<br/>
Especifica o raio do círculo em unidades lógicas. Esse valor deve ser positivo.

*fStartAngle*<br/>
Especifica o ângulo inicial em graus em relação ao eixo x.

*fSweepAngle*<br/>
Especifica o ângulo de flecha em graus em relação ao ângulo inicial.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

O segmento de linha é desenhado da posição atual para o início do arco. O arco é desenhado ao longo do perímetro de um círculo com o centro e um determinado raio. O tamanho do arco é definido pelos ângulos de início e de varredura de determinado.

`AngleArc` Move a posição atual para o ponto final do arco. O arco desenhado por essa função pode parecer ser elíptico, dependendo do modo de mapeamento e a transformação atual. Antes de desenhar o arco, essa função desenha o segmento de linha da posição atual para o início do arco. O arco é desenhado com a construção de um círculo imaginário com raio especificado em torno do ponto central especificado. O ponto de partida do arco é determinado pela medição no sentido anti-horário partindo do eixo x do círculo pelo número de graus no ângulo inicial. Da mesma forma, o ponto final está localizado, medindo no sentido anti-horário do ponto de partida pelo número de graus em que o ângulo de flecha.

Se o ângulo de flecha é maior que 360 graus o arco é limpo várias vezes. Essa função desenha linhas, usando a caneta atual. A figura não está preenchida.

##  <a name="arc"></a>  CDC::Arc

Desenha um arco elíptico.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar qualquer um LPRECT ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de final do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O arco desenhado usando a função é um segmento da elipse definida por um retângulo delimitador especificado.

O ponto de partida real do arco é o ponto em que um raio desenhado do centro do retângulo delimitador por meio do ponto de partida especificado faz interseção com a elipse. O ponto final real do arco é o ponto em que um raio desenhado do centro do retângulo delimitador por meio do ponto final especificado faz interseção com a elipse. O arco é desenhado no sentido anti-horário. Como um arco não é uma figura fechada, ela não está preenchida. A largura e a altura do retângulo devem ser maiores que 2 unidades e unidades inferior a 32.767.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

Desenha um arco elíptico.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y3*<br/>
Especifica a coordenada y do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura de dados ou uma [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define o arco inicial ponto (em unidades lógicas). Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura de dados ou uma [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de final do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma `POINT` estrutura de dados ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função é semelhante ao `CDC::Arc`, exceto que a posição atual é atualizada. Os pontos ( *x1*, *y1*) e ( *x2*, *y2*) especificam o retângulo delimitador. Uma elipse formada pelo retângulo delimitador determinado define a curva do arco. O arco no sentido anti-horário estende (a direção padrão de arco) do ponto em que ele faz interseção com a linha radial do centro do retângulo delimitador para ( *x3*, *y3*). O término do arco onde ele cruza a linha radial do centro do retângulo delimitador para ( *x4*, *y4*). Se o ponto de partida e final são os mesmos, uma elipse completa é desenhada.

Uma linha é desenhada da posição atual para o ponto de partida do arco. Se nenhum erro ocorrer, a posição atual está definida como o ponto final do arco. O arco é desenhado usando a caneta atual; não foi preenchido.

##  <a name="attach"></a>  CDC::Attach

Use essa função de membro para anexar uma *hDC* para o `CDC` objeto.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O *hDC* estão armazenadas nos `m_hDC`, o contexto de dispositivo de saída e, em `m_hAttribDC`, o contexto de dispositivo do atributo.

##  <a name="beginpath"></a>  CDC::BeginPath

Abre um colchete de caminho no contexto de dispositivo.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois de abrir um colchete de caminho, um aplicativo pode começar a chamar funções de desenho do GDI para definir os pontos que estão no caminho. Um aplicativo pode fechar um colchete de caminho aberto chamando o `EndPath` função de membro. Quando um aplicativo chama `BeginPath`, todos os caminhos anteriores são descartados.

Ver [BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) no SDK do Windows para obter uma lista das funções de desenho que definem pontos em um caminho.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

Copia um bitmap do contexto do dispositivo de origem para este contexto de dispositivo atual.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do bitmap retângulo e a fonte de destino.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do bitmap retângulo e a fonte de destino.

*pSrcDC*<br/>
Ponteiro para um `CDC` objeto que identifica o contexto de dispositivo do qual o bitmap será copiado. Ele deve ser NULL se *dwRop* Especifica uma operação de varredura que não inclui uma código-fonte.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do bitmap de origem.

*dwRop*<br/>
Especifica a operação de varredura a ser executada. Códigos de operação de varredura definem como a GDI combina cores nas operações de saída que envolvem um pincel, um possível bitmap de origem e um bitmap de destino. Ver [BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt) no SDK do Windows para obter uma lista dos códigos de operação de varredura para *dwRop* e suas descrições

Para obter uma lista completa dos códigos de operação de varredura, consulte [sobre códigos de operação de varredura](/windows/desktop/gdi/raster-operation-codes) no SDK do Windows.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O aplicativo pode alinhar o windows ou áreas de cliente em limites de byte para garantir que o `BitBlt` as operações ocorrem em retângulos bytes alinhado. (Definir os sinalizadores CS_BYTEALIGNWINDOW ou CS_BYTEALIGNCLIENT ao registrar as classes de janela).

`BitBlt` operações em bytes alinhado retângulos são consideravelmente mais rápidas que `BitBlt` operações em retângulos que não estão alinhados bytes. Se você quiser especificar os estilos de classe, como alinhamento de bytes para seu próprio contexto de dispositivo, você terá que registrar uma classe de janela em vez de contar com as Microsoft Foundation classes para fazer isso para você. Use a função global [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass).

Transforma GDI *nWidth* e *nHeight*, uma vez usando o contexto de dispositivo de destino e uma vez usando o contexto de dispositivo de origem. Se as extensões resultantes não corresponderem, a GDI usa o Windows `StretchBlt` função por compactar ou alongar o bitmap de origem conforme necessário.

Se o destino, origem e bitmaps padrão não têm o mesmo formato de cor, o `BitBlt` função converte os bitmaps de origem e padrão para coincidir com o destino. As cores de primeiro plano e plano de fundo de bitmap de destino são usadas na conversão.

Quando o `BitBlt` função converte um bitmap monocromático em cor, ele definirá bits brancos (1) para a cor do plano de fundo e bits pretos (0) para a cor de primeiro plano. As cores de primeiro plano e plano de fundo do contexto de dispositivo de destino são usadas. Converter cor em monocromático, `BitBlt` define pixels que correspondam a cor do plano de fundo para branco e define todos os outros pixels para preto. `BitBlt` usa as cores de primeiro plano e plano de fundo do contexto de dispositivo de cor para converter de cor em monocromático.

Observe que nem todos os contextos de dispositivo dão suporte ao `BitBlt`. Para verificar se um determinado contexto de dispositivo dá suporte `BitBlt`, use o `GetDeviceCaps` membro de função e especifique o índice RASTERCAPS.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::CreateCompatibleDC](#createcompatibledc).

##  <a name="cdc"></a>  CDC::CDC

Constrói um objeto `CDC`.

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

Desenha uma corda (uma figura fechada limitada pela interseção de uma elipse e um segmento de linha).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica que a coordenada x do canto superior esquerdo da sequência de teclas delimitadora do retângulo (em unidades lógicas).

*y1*<br/>
Especifica que a coordenada y do canto superior esquerdo da sequência de teclas delimitadora do retângulo (em unidades lógicas).

*x2*<br/>
Especifica que a coordenada x do canto inferior direito da sequência de teclas delimitadora do retângulo (em unidades lógicas).

*y2*<br/>
Especifica que a coordenada y do canto inferior direito da sequência de teclas delimitadora do retângulo (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto que define a sequência de teclas do ponto (em unidades lógicas) inicial.

*y3*<br/>
Especifica a coordenada y do ponto que define a sequência de teclas do ponto (em unidades lógicas) inicial.

*x4*<br/>
Especifica a coordenada x do ponto que define o ponto de extremidade da sequência de teclas (em unidades lógicas).

*y4*<br/>
Especifica a coordenada y do ponto que define o ponto de extremidade da sequência de teclas (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar qualquer um LPRECT ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*ptStart*<br/>
Especifica as coordenadas x e y do ponto que define a sequência de teclas do ponto (em unidades lógicas) inicial. Esse ponto não precisa ajustar-se exatamente a sequência de teclas. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

*ptEnd*<br/>
Especifica as coordenadas x e y do ponto que define o ponto de final da sequência de teclas (em unidades lógicas). Esse ponto não precisa ajustar-se exatamente a sequência de teclas. Você pode transmitir uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O ( *x1*, *y1*) e ( *x2*, *y2*) os parâmetros especificam os cantos superior esquerdo e inferior direito, respectivamente, de um retângulo limite da elipse que faz parte do que a sequência de teclas. O ( *x3*, *y3*) e ( *x4*, *y4*) os parâmetros especificam os pontos de extremidade de uma linha que intercepta a elipse. A sequência de teclas é desenhada usando a caneta selecionada e preenchida usando o pincel selecionado.

A Figura desenhada pelo `Chord` função estende até, mas não inclui as coordenadas da direita e inferior. Isso significa que a altura da figura *y2* - *y1* e a largura da figura é *x2* - *x1*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

Fecha uma figura aberta em um caminho.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função fecha a Figura desenhando uma linha da posição atual até o primeiro ponto da figura (normalmente, o ponto especificado pela chamada mais recente para o `MoveTo` função de membro) e conecta-se as linhas usando o estilo de junção de linha. Se uma figura está fechada usando o `LineTo` função de membro em vez de `CloseFigure`, delimitada é usadas para criar o canto, em vez de uma junção. `CloseFigure` só deve ser chamado se houver um colchete de caminho aberto no contexto de dispositivo.

Uma figura em um caminho está aberta, a menos que ela é fechada explicitamente usando essa função. (Uma figura pode ser aberta, mesmo se o ponto atual e o ponto de partida da figura forem iguais.) Qualquer linha ou curva adicionado ao caminho após `CloseFigure` inicia uma nova figura.

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

Cria um contexto de dispositivo de memória que é compatível com o dispositivo especificado pelo *pDC*.

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Parâmetros

*pDC*<br/>
Um ponteiro para um contexto de dispositivo. Se *pDC* for NULL, a função cria um contexto de dispositivo de memória que é compatível com a exibição do sistema.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um contexto de dispositivo de memória é um bloco de memória que representa uma superfície de exibição. Ele pode ser usado para preparar imagens na memória antes de copiá-los para a superfície do dispositivo real do dispositivo compatível.

Quando um contexto de dispositivo de memória é criado, GDI seleciona automaticamente um bitmap de estoque monocromático 1-por-1 para ele. Funções de GDI de saída podem ser usadas com um contexto de dispositivo de memória somente se um bitmap foi criado e selecionado em que o contexto.

Essa função só pode ser usada para criar os contextos de dispositivo compatível para dispositivos que dão suporte a operações de varredura. Consulte a [CDC::BitBlt](#bitblt) a função de membro para obter informações sobre as transferências entre contextos de dispositivo de bloco de bits. Para determinar se um contexto de dispositivo dá suporte a operações de varredura, consulte o recurso de varredura RC_BITBLT na função de membro `CDC::GetDeviceCaps`.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

Cria um contexto de dispositivo para o dispositivo especificado.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do arquivo (sem extensão) do driver de dispositivo (por exemplo, "EPSON"). Você também pode passar um `CString` objeto para esse parâmetro.

*lpszDeviceName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do dispositivo específico com suporte (por exemplo, "EPSON FX-80"). O *lpszDeviceName* parâmetro será usado se o módulo dá suporte a mais de um dispositivo. Você também pode passar um `CString` objeto para esse parâmetro.

*lpszOutput*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome de arquivo ou dispositivo para a mídia de saída físico (porta de saída ou de arquivo). Você também pode passar um `CString` objeto para esse parâmetro.

*lpInitData*<br/>
Aponta para um `DEVMODE` estrutura que contém dados específicos do dispositivo de inicialização para o driver de dispositivo. O Windows `DocumentProperties` função recupera essa estrutura preenchida para um determinado dispositivo. O *lpInitData* parâmetro deverá ser NULL se o driver de dispositivo é usar a inicialização padrão (se houver) especificada pelo usuário por meio do painel de controle.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A impressão. Arquivo de cabeçalho de H será necessário se o [DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea) estrutura é usada.

Nomes de dispositivo seguem essas convenções: final um dois-pontos (:) são opcional, mas recomendada. Windows retira os dois-pontos de terminação, para que um nome de dispositivo, terminando com dois-pontos é mapeado para a mesma porta que o mesmo nome sem dois-pontos. Os nomes de driver e a porta não devem conter espaços à esquerda ou à direita. Funções de GDI de saída não podem ser usadas com contextos de informações.

##  <a name="createic"></a>  CDC::CreateIC

Cria um contexto de informações para o dispositivo especificado.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Parâmetros

*lpszDriverName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do arquivo (sem extensão) do driver de dispositivo (por exemplo, "EPSON"). Você pode passar um `CString` objeto para esse parâmetro.

*lpszDeviceName*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome do dispositivo específico com suporte (por exemplo, "EPSON FX-80"). O *lpszDeviceName* parâmetro será usado se o módulo dá suporte a mais de um dispositivo. Você pode passar um `CString` objeto para esse parâmetro.

*lpszOutput*<br/>
Aponta para uma cadeia de caracteres terminada em nulo que especifica o nome de arquivo ou dispositivo para a mídia de saída físico (arquivo ou porta). Você pode passar um `CString` objeto para esse parâmetro.

*lpInitData*<br/>
Aponta para dados específicos do dispositivo de inicialização para o driver de dispositivo. O *lpInitData* parâmetro deverá ser NULL se o driver de dispositivo é usar a inicialização padrão (se houver) especificada pelo usuário por meio do painel de controle. Consulte `CreateDC` para o formato de dados específicos do dispositivo de inicialização.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto de informações fornece uma maneira rápida de obter informações sobre o dispositivo sem criar um contexto de dispositivo.

Nomes de dispositivo seguem essas convenções: final um dois-pontos (:) são opcional, mas recomendada. Windows retira os dois-pontos de terminação, para que um nome de dispositivo, terminando com dois-pontos é mapeado para a mesma porta que o mesmo nome sem dois-pontos. Os nomes de driver e a porta não devem conter espaços à esquerda ou à direita. Funções de GDI de saída não podem ser usadas com contextos de informações.

##  <a name="deletedc"></a>  CDC::DeleteDC

Em geral, não chame essa função; o destruidor fará isso para você.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função foi concluída com êxito; Caso contrário, 0.

### <a name="remarks"></a>Comentários

O `DeleteDC` função de membro exclui os contextos de dispositivo do Windows que estão associados `m_hDC` atual `CDC` objeto. Se este `CDC` objeto é o último contexto de dispositivo ativo para um determinado dispositivo, o dispositivo é notificado e todos os recursos de armazenamento e do sistema usados pelo dispositivo são liberados.

Um aplicativo não deve chamar `DeleteDC` se os objetos selecionados no contexto de dispositivo. Objetos devem ser selecionados primeiro fora do contexto de dispositivo antes de ser excluído.

Um aplicativo não pode excluir um contexto de dispositivo cujo identificador foi obtido chamando [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Em vez disso, ele deverá chamar [CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc) para liberar o contexto de dispositivo. O [CClientDC](../../mfc/reference/cclientdc-class.md) e [CWindowDC](../../mfc/reference/cwindowdc-class.md) classes são fornecidas para encapsular essa funcionalidade.

O `DeleteDC` função geralmente é usada para excluir os contextos de dispositivo criados com [CreateDC](#createdc), [CreateIC](#createic), ou [CreateCompatibleDC](#createcompatibledc).

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

Chamado automaticamente pelo `CWinApp` manipulador de tempo ocioso `DeleteTempMap` exclui qualquer temporário `CDC` objetos criados pelo `FromHandle`, mas não destrói os identificadores de contexto de dispositivo ( `hDC`s) temporariamente associado com o `CDC` objetos.

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

Chame essa função para desanexar `m_hDC` (o contexto de dispositivo de saída) do `CDC` do objeto e defina `m_hDC` e `m_hAttribDC` como NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Valor de retorno

Um contexto de dispositivo do Windows.

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

Use essa função ao conceder tamanhos HIMETRIC a OLE, convertendo os pixels em HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto de dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, a conversão é baseada no número de pixels em polegadas a física. Se o modo de mapeamento é um dos outros modos não limitado (por exemplo, MM_TEXT), a conversão é baseada no número de pixels a polegada lógica.

##  <a name="dptolp"></a>  CDC::DPtoLP

Converte as unidades de dispositivo em unidades lógicas.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas ou [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objetos.

*nCount*<br/>
O número de pontos da matriz.

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto. Esse parâmetro é usado para o caso mais simples de conversão de um retângulo de pontos de dispositivo aos pontos de lógicos.

*lpSize*<br/>
Aponta para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto ou dimensão de tamanho, do sistema de coordenadas de dispositivo no sistema de coordenadas lógico da GDI. A conversão depende do modo de mapeamento atual e as configurações das origens e extensões para a janela do dispositivo e o visor.

##  <a name="draw3drect"></a>  CDC::Draw3dRect

Chame essa função de membro para desenhar um retângulo tridimensional.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*clrTopLeft*<br/>
Especifica a cor dos lados superior e esquerdos do retângulo tridimensional.

*clrBottomRight*<br/>
Especifica a cor da parte inferior e à direita do retângulo tridimensional.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo tridimensional.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo tridimensional.

*cx*<br/>
Especifica a largura do retângulo tridimensional.

*cy*<br/>
Especifica a altura do retângulo tridimensional.

### <a name="remarks"></a>Comentários

O retângulo será desenhado com os lados superior e esquerdos na cor especificada por *clrTopLeft* e a parte inferior e à direita na cor especificada por *clrBottomRight*.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

Chame essa função de membro repetidamente para redesenhar um retângulo de arrastar.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que especifica as coordenadas lógicas de um retângulo — neste caso, a posição final do retângulo que está sendo redesenhada.

*size*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) de um retângulo.

*lpRectLast*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que especifica as coordenadas lógicas da posição de um retângulo — neste caso, a posição original do retângulo que está sendo redesenhada.

*sizeLast*<br/>
Especifica o deslocamento do canto superior esquerdo da borda externa para o canto superior esquerdo da borda interna (ou seja, a espessura da borda) do retângulo original que está sendo redesenhada.

*pBrush*<br/>
Ponteiro para um objeto de pincel. Definido como nulo para usar o pincel de meio-tom padrão.

*pBrushLast*<br/>
Ponteiro para o último objeto de pincel usado. Definido como nulo para usar o pincel de meio-tom padrão.

### <a name="remarks"></a>Comentários

Chamá-lo em um loop, conforme o exemplo a posição do mouse, para fornecer comentários visuais. Quando você chama `DrawDragRect`, o retângulo anterior é apagado e um novo é desenhado. Por exemplo, como o usuário arrasta um retângulo pela tela, `DrawDragRect` irá apagar o retângulo original e a redesenhar a um novo em sua nova posição. Por padrão, `DrawDragRect` desenha o retângulo usando um pincel de meio-tom para eliminar a cintilação e para criar a aparência de um retângulo movendo sem problemas.

Na primeira vez que você chame `DrawDragRect`, o *lpRectLast* parâmetro deve ser NULL.

##  <a name="drawedge"></a>  CDC::DrawEdge

Chame essa função de membro para desenhar as bordas de um retângulo do tipo especificado e estilo.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Um ponteiro para um `RECT` estrutura que contém as coordenadas lógicas do retângulo.

*nEdge*<br/>
Especifica o tipo de borda interna e externa para desenhar. Esse parâmetro deve ser uma combinação de um sinalizador de borda interna e um sinalizador de borda externa. Ver [DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) no SDK do Windows para uma tabela de tipos do parâmetro.

*nFlags*<br/>
Os sinalizadores que especificam o tipo de borda a ser desenhada. Consulte `DrawEdge` no SDK do Windows para uma tabela de valores do parâmetro. Para linhas diagonais, os sinalizadores BF_RECT especificam o ponto de extremidade do vetor limitado pelo parâmetro do retângulo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

##  <a name="drawescape"></a>  CDC::DrawEscape

Acessos a recursos que não estão diretamente disponíveis por meio da interface de dispositivo de gráficos (GDI) de um monitor de vídeo de desenho.

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados para o *lpszInputData* parâmetro.

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessários para o escape especificado.

### <a name="return-value"></a>Valor de retorno

Especifica o resultado da função. Maior que zero se tiver êxito, exceto para o escape de desenho QUERYESCSUPPORT, que verifica se há implementação apenas; ou zero se o escape não for implementado; ou menor que zero, se um erro ocorreu.

### <a name="remarks"></a>Comentários

Quando um aplicativo chama `DrawEscape`, os dados identificados por *nInputSize* e *lpszInputData* é passada diretamente para o driver de vídeo especificada.

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

Desenha um retângulo no estilo usado para indicar que o retângulo tem o foco.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que especifica as coordenadas lógicas do retângulo a ser desenhado.

### <a name="remarks"></a>Comentários

Como essa é uma função XOR booliano, chamar essa função em uma segunda vez com o mesmo retângulo remove o retângulo da exibição. O retângulo desenhado por essa função não pode ser rolado. Para rolar uma área que contém um retângulo desenhado por essa função, primeiro chame `DrawFocusRect` para remover o retângulo de exibição, em seguida, role a área e, em seguida, chamar `DrawFocusRect` novamente para desenhar o retângulo na nova posição.

> [!CAUTION]
> `DrawFocusRect` funciona apenas no modo MM_TEXT. Em outros modos, essa função não desenhar o retângulo de foco corretamente, mas não retorna valores de erro.

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

Chame essa função de membro para desenhar um controle de quadro do tipo especificado e estilo.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Um ponteiro para um `RECT` estrutura que contém as coordenadas lógicas do retângulo.

*nType*<br/>
Especifica o tipo de controle de quadro no qual desenhar. Consulte a *uType* parâmetro na [DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) no SDK do Windows para obter uma lista de valores possíveis desse parâmetro.

*nState*<br/>
Especifica o estado inicial do controle de quadro. Pode ser um ou mais dos valores descritos para a *uState* parâmetro em `DrawFrameControl` no SDK do Windows. Use o *nState* DFCS_ADJUSTRECT para ajustar o retângulo delimitador para excluir a borda ao redor do botão de envio por push do valor.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

Em muitos casos, *nState* depende o *nType* parâmetro. A lista a seguir mostra a relação entre as quatro *nType* valores e *nState*:

- DFC_BUTTON

    - Botão de três estados DFCS_BUTTON3STATE

    - Caixa de seleção DFCS_BUTTONCHECK

    - Botão Enviar por Push DFCS_BUTTONPUSH

    - Botão de opção DFCS_BUTTONRADIO

    - Imagem de DFCS_BUTTONRADIOIMAGE para botão de opção (não quadrados precisa de imagem)

    - Máscara de DFCS_BUTTONRADIOMASK para botão de opção (não quadrados precisa máscara)

- DFC_CAPTION

    - Botão Fechar DFCS_CAPTIONCLOSE

    - Botão Ajuda DFCS_CAPTIONHELP

    - Botão Maximizar DFCS_CAPTIONMAX

    - Botão Minimizar DFCS_CAPTIONMIN

    - Botão Restaurar DFCS_CAPTIONRESTORE

- DFC_MENU

    - Seta de Submenu DFCS_MENUARROW

    - Marcador DFCS_MENUBULLET

    - Marca de seleção DFCS_MENUCHECK

- DFC_SCROLL

    - Barra de rolagem de caixa de combinação DFCS_SCROLLCOMBOBOX

    - DFCS_SCROLLDOWN seta para baixo da barra de rolagem

    - Seta para a esquerda DFCS_SCROLLLEFT da barra de rolagem

    - Seta para a direita DFCS_SCROLLRIGHT da barra de rolagem

    - DFCS_SCROLLSIZEGRIP alça de dimensionamento no canto inferior direito da janela

    - Seta DFCS_SCROLLUP acima da barra de rolagem

### <a name="example"></a>Exemplo

Esse código desenha garra tamanho no canto inferior direito da janela. Ele é apropriado para o `OnPaint` manipulador de uma caixa de diálogo, que não tem nenhum estilo e normalmente não contém outros controles (como uma barra de status) que podem dar a ele uma garra de tamanho.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

Desenha um ícone no dispositivo representado pelo atual `CDC` objeto.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do ícone.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do ícone.

*hIcon*<br/>
Identifica o identificador do ícone a ser desenhado.

*point*<br/>
Especifica a lógica coordenadas x e y-do canto superior esquerdo do ícone. Você pode passar uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função foi concluída com êxito; Caso contrário, 0.

### <a name="remarks"></a>Comentários

A função coloca o canto superior esquerdo do ícone no local especificado por *x* e *y*. O local está sujeito ao modo de mapeamento atual do contexto do dispositivo.

O recurso de ícone deve ter sido carregado usando as funções `CWinApp::LoadIcon`, `CWinApp::LoadStandardIcon`, ou `CWinApp::LoadOEMIcon`. O `MM_TEXT` modo de mapeamento deve ser selecionado antes de usar essa função.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

##  <a name="drawstate"></a>  CDC::DrawState

Chame essa função de membro para exibir uma imagem e aplicar um efeito visual para indicar um estado, como desabilitado ou o estado padrão.

> [!NOTE]
>  Para todos os *Nalização* estados, exceto DSS_NORMAL, a imagem é convertida em monocromático antes que o efeito visual é aplicado.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Parâmetros

*pt*<br/>
Especifica o local da imagem.

*size*<br/>
Especifica o tamanho da imagem.

*hBitmap*<br/>
Um identificador para um bitmap.

*nFlags*<br/>
Sinalizadores que especificam o tipo de imagem e o estado. Ver [DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) no SDK do Windows para o possível *nFlags* estados e tipos.

*hBrush*<br/>
Um identificador para um pincel.

*pBitmap*<br/>
Um ponteiro para um objeto CBitmap.

*pBrush*<br/>
Um ponteiro para um objeto CBrush.

*hIcon*<br/>
Um identificador para um ícone.

*lpszText*<br/>
Um ponteiro para o texto.

*bPrefixText*<br/>
Texto que pode conter um mnemônico de acelerador. O *lData* parâmetro especifica o endereço da cadeia de caracteres e o *nTextLen* parâmetro especifica o comprimento. Se *nTextLen* for 0, a cadeia de caracteres deve para ser terminada em nulo.

*nTextLen*<br/>
Comprimento da cadeia de caracteres de texto apontada por *lpszText*. Se *nTextLen* for 0, a cadeia de caracteres deve para ser terminada em nulo.

*lpDrawProc*<br/>
Um ponteiro para uma função de retorno de chamada usada para renderizar uma imagem. Esse parâmetro é necessário se a imagem de digitar *nFlags* é DST_COMPLEX. Ele é opcional e pode ser NULL se o tipo de imagem for DST_TEXT. Para todos os outros tipos de imagem, esse parâmetro é ignorado. Para obter mais informações sobre a função de retorno de chamada, consulte a [DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) função no SDK do Windows.

*lData*<br/>
Especifica informações sobre a imagem. O significado desse parâmetro depende do tipo de imagem.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

##  <a name="drawtext"></a>  CDC::DrawText

Chame essa função de membro para formatar o texto no retângulo determinado. Para especificar opções de formatação adicionais, use [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhado. Se *nCount* é -1, a cadeia de caracteres deve ser terminada em nulo.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, em seguida, *lpszString* será considerado como um ponteiro longo para uma cadeia de caracteres terminada em nulo e `DrawText` calcula o número de caracteres automaticamente.

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que contém o retângulo (em coordenadas lógicas) na qual o texto deve ser formatado.

*str*<br/>
Um [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto que contém os caracteres especificados ser desenhado.

*nFormat*<br/>
Especifica o método de formatação de texto. Ele pode ser qualquer combinação dos valores descritos para a *uFormat* parâmetro na [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) no SDK do Windows. (combine com o operador OR bit a bit):

> [!NOTE]
>  Alguns *uFormat* combinações de sinalizador podem fazer com que a cadeia de caracteres transmitida a ser modificado. Usar DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer com que a cadeia de caracteres a ser modificada, causando uma asserção no `CString` substituir. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser usados com o valor DT_TABSTOP.

### <a name="return-value"></a>Valor de retorno

A altura do texto se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

Formata o texto, expandindo guias em espaços apropriados, alinhar texto à esquerda, direita, ou o centro do retângulo determinado e quebrar o texto em linhas que se encaixam dentro do retângulo especificado. O tipo de formatação é especificado pelo *nFormat*.

Essa função membro usa o contexto de dispositivo fonte selecionada, a cor do texto e cor do plano de fundo para desenhar o texto. A menos que o formato DT_NOCLIP é usado, `DrawText` recorta o texto para que o texto não sejam exibidos fora do retângulo especificado. Toda a formatação será assumido para ter várias linhas, a menos que o formato DT_SINGLELINE é fornecido.

Se a fonte selecionada é grande demais para o retângulo especificado, o `DrawText` função de membro não tenta substituir por uma fonte menor.

Se o sinalizador DT_CALCRECT for especificado, o retângulo especificado por *lpRect* será atualizada para refletir a largura e altura necessária para desenhar o texto.

Se o sinalizador de alinhamento de texto TA_UPDATECP tiver sido definido (consulte [CDC::SetTextAlign](#settextalign)), `DrawText` exibirá o texto, iniciando na posição atual, em vez de na parte esquerda do retângulo especificado. `DrawText` não será quebrado quando o sinalizador TA_UPDATECP foi definido (ou seja, o sinalizador DT_WORDBREAK não terá efeito).

A cor do texto pode ser definida [CDC::SetTextColor](#settextcolor).

##  <a name="drawtextex"></a>  CDC::DrawTextEx

Formata o texto no retângulo determinado.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhado. Se *nCount* é -1, a cadeia de caracteres deve ser finalizada com null.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, em seguida, *lpszString* será considerado como um ponteiro longo para uma cadeia de caracteres terminada em nulo e `DrawText` calcula o número de caracteres automaticamente.

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que contém o retângulo (em coordenadas lógicas) na qual o texto deve ser formatado.

*str*<br/>
Um [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto que contém os caracteres especificados ser desenhado.

*nFormat*<br/>
Especifica o método de formatação de texto. Ele pode ser qualquer combinação dos valores descritos para a *uFormat* parâmetro na [DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) no SDK do Windows. (Usando o bit a bit de combinar **ou** operador):

> [!NOTE]
>  Alguns *uFormat* combinações de sinalizador podem fazer com que a cadeia de caracteres transmitida a ser modificado. Usar DT_MODIFYSTRING com DT_END_ELLIPSIS ou DT_PATH_ELLIPSIS pode fazer com que a cadeia de caracteres a ser modificada, causando uma asserção no `CString` substituir. Os valores DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP e DT_NOPREFIX não podem ser usados com o valor DT_TABSTOP.

*lpDTParams*<br/>
Ponteiro para um [DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams) opções de estrutura que especifica a formatação adicional. Esse parâmetro pode ser NULL.

### <a name="remarks"></a>Comentários

Formata o texto, expandindo guias em espaços apropriados, alinhar texto à esquerda, direita, ou o centro do retângulo determinado e quebrar o texto em linhas que se encaixam dentro do retângulo especificado. O tipo de formatação é especificado pelo *nFormat* e *lpDTParams*. Para obter mais informações, consulte [CDC::DrawText](#drawtext) e [DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) no SDK do Windows.

A cor do texto pode ser definida [CDC::SetTextColor](#settextcolor).

##  <a name="ellipse"></a>  CDC::Ellipse

Desenha uma elipse.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo delimitador da elipse.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo delimitador da elipse.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo delimitador da elipse.

*y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo delimitador da elipse.

*lpRect*<br/>
Especifica que a elipse do retângulo delimitador. Você também pode passar uma [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro da elipse é o centro do retângulo delimitador especificado por *x1*, *y1*, *x2*, e *y2*, ou  *lpRect*. A elipse é desenhada com a caneta atual e seu interior é preenchido com o pincel atual.

A Figura desenhada por essa função se estende até, mas não inclui as coordenadas da direita e inferior. Isso significa que a altura da figura *y2* - *y1* e a largura da figura é *x2* - *x1*.

Se a largura ou a altura do retângulo delimitador for 0, nenhuma elipse é desenhada.

##  <a name="enddoc"></a>  CDC::EndDoc

Termina um trabalho de impressão iniciado por uma chamada para o [StartDoc](#startdoc) função de membro.

```
int EndDoc();
```

### <a name="return-value"></a>Valor de retorno

Maior que ou igual a 0 se a função for bem-sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

Essa função membro substitui o escape de impressora ENDDOC e deve ser chamada imediatamente depois de concluir um trabalho de impressão com êxito.

Se um aplicativo encontra um erro de impressão ou uma operação de impressão cancelada, ele não deve tentar encerrar a operação usando o `EndDoc` ou [AbortDoc](#abortdoc). GDI automaticamente encerra a operação antes de retornar o valor de erro.

Essa função não deve ser usada dentro de metarquivos.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::StartDoc](#startdoc).

##  <a name="endpage"></a>  CDC::EndPage

Informa ao dispositivo que o aplicativo foi concluída a gravação em uma página.

```
int EndPage();
```

### <a name="return-value"></a>Valor de retorno

Maior que ou igual a 0 se a função for bem-sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

Essa função de membro normalmente é usada para direcionar o driver de dispositivo para ir para uma nova página.

Essa função membro substitui o escape de impressora NEWFRAME. Ao contrário de NEWFRAME, essa função sempre é chamada depois de imprimir uma página.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::StartDoc](#startdoc).

##  <a name="endpath"></a>  CDC::EndPath

Fecha um colchete de caminho e seleciona o caminho definido pelo suporte para o contexto de dispositivo.

```
BOOL EndPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC:: beginpath](#beginpath).

##  <a name="enumobjects"></a>  CDC::EnumObjects

Enumera as canetas e pincéis disponíveis em um contexto de dispositivo.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Parâmetros

*nObjectType*<br/>
Especifica o tipo de objeto. Ele pode ter os valores OBJ_BRUSH ou OBJ_PEN.

*lpfn*<br/>
É o endereço da instância do procedimento da função de retorno de chamada fornecida pelo aplicativo. Consulte a seção "Comentários" abaixo.

*lpData*<br/>
Pontos de dados fornecida pelo aplicativo. Os dados são passados para a função de retorno de chamada juntamente com as informações de objeto.

### <a name="return-value"></a>Valor de retorno

Especifica o último valor retornado pela [função de retorno de chamada](callback-functions-used-by-mfc.md#enum_objects). Seu significado é definido pelo usuário.

### <a name="remarks"></a>Comentários

Para cada objeto de um determinado tipo, a função de retorno de chamada que você transmite é chamada com as informações para esse objeto. O sistema chama a função de retorno de chamada até que não existem mais objetos ou a função de retorno de chamada retorna 0.

Observe que novos recursos do Microsoft Visual C++ permitem que você use uma função comum como a função passada para `EnumObjects`. O endereço passado para `EnumObjects` é um ponteiro para uma função exportada com **exportar** e com o convenção de chamada Pascal. Em aplicativos de modo de segurança, não é preciso criar esta função com a função em Windows MakeProcInstanc ou libere a função após o uso com a função FreeProcInstance Windows.

Também não é necessário exportar o nome da função em uma **exportações** instrução no arquivo de definição de módulo do seu aplicativo. Em vez disso, você pode usar o **exportar** função modificador, como em

**int exportar de retorno de chamada** AFunction **(LPSTR**, **LPSTR);**

Para fazer com que o compilador emita o registro de exportação apropriadas para exportação por nome sem alias. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como exportar uma função por ordinal ou alias a exportação, você ainda precisa usar um **exportações** instrução em um arquivo de definição de módulo.

Para compilar programas do Microsoft Foundation, você usará normalmente o /GA e opções do compilador /GEs. A opção de compilador /Gw não é usada com as Microsoft Foundation classes. (Se você usar a função Windows `MakeProcInstance`, será necessário converter explicitamente o ponteiro de função retornado de FARPROC para o tipo necessário nessa API.) Interfaces de registro de retorno de chamada agora são fortemente tipadas (você deve passar um ponteiro de função que aponta para o tipo correto de função para o retorno de chamada específico).

Além disso, observe que todas as funções de retorno de chamada devem interceptar as exceções do Microsoft Foundation antes de retornar ao Windows, já que as exceções não podem ser geradas entre limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

Essa função membro é praticamente obsoleta para programação Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Parâmetros

*nEscape*<br/>
Especifica a função de escape a ser executada.

Para obter uma lista completa das funções de escape, consulte [Escape](/windows/desktop/api/wingdi/nf-wingdi-escape) no SDK do Windows.

*nCount*<br/>
Especifica o número de bytes dos dados apontados por *lpszInData*.

*lpszInData*<br/>
Aponta para a estrutura de dados de entrada necessários para este escape.

*lpOutData*<br/>
Aponta para a estrutura que deve receber a saída deste escape. O *lpOutData* parâmetro será nulo se nenhum dado será retornado.

*nInputSize*<br/>
Especifica o número de bytes de dados apontados para o *lpszInputData* parâmetro.

*lpszInputData*<br/>
Aponta para a estrutura de entrada necessários para o escape especificado.

*nOutputSize*<br/>
Especifica o número de bytes de dados apontados para o *lpszOutputData* parâmetro.

*lpszOutputData*<br/>
Aponta para a estrutura que recebe a saída deste escape. Esse parâmetro deve ser NULL se nenhum dado será retornado.

### <a name="return-value"></a>Valor de retorno

Um valor positivo será retornado se a função for bem-sucedida, exceto para o escape QUERYESCSUPPORT, que verifica apenas para implementação. Zero será retornado se o escape não está implementado. Um valor negativo será retornado se ocorreu um erro. Os seguintes valores de erro comuns são:

- Erro geral de SP_ERROR.

- Não SP_OUTOFDISK espaço em disco suficiente está disponível atualmente para o spool e não há mais espaço se tornará disponível.

- SP_OUTOFMEMORY não há memória suficiente está disponível para o spool.

- Usuário SP_USERABORT terminou o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Das original escapes de impressora, QUERYESCSUPPORT só tem suporte para aplicativos Win32. Todos os outros escapes de impressora são obsoletos e têm suporte somente para compatibilidade com aplicativos de 16 bits.

Para a programação do Win32, `CDC` agora fornece seis funções de membro que substituem seus correspondentes escapes de impressora:

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Além disso, [CDC::GetDeviceCaps](#getdevicecaps) dá suporte a índices de Win32 que substituem outros escapes de impressora. Ver [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) no SDK do Windows para obter mais informações.

Essa função membro permite que aplicativos acessem os recursos de um determinado dispositivo que não estão diretamente disponíveis através de GDI.

Use a primeira versão, se seu aplicativo usa os valores de escape predefinidos. Use a segunda versão, se seu aplicativo define os valores de escape privada. Ver [ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape) no SDK do Windows para obter mais informações sobre a segunda versão.

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

Cria uma nova região de recorte que consiste de recorte existente menos o retângulo especificado.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo.

*lpRect*<br/>
Especifica o retângulo. Também pode ser um `CRect` objeto.

### <a name="return-value"></a>Valor de retorno

Especifica o tipo da nova região de recorte. Ele pode ser qualquer um dos seguintes valores:

- COMPLEXREGION a região tem bordas de sobreposição.

- Erro nenhuma região foi criado.

- NULLREGION a região está vazia.

- A região SIMPLEREGION tem sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

A largura do retângulo, especificado pelo valor absoluto *x2* - *x1*, não deve exceder 32.767 unidades. Esse limite se aplica à altura do retângulo também.

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

Impede que o desenho nas áreas inválidos de uma janela, excluindo uma região atualizada na janela da região de recorte associado com o `CDC` objeto.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Parâmetros

*pWnd*<br/>
Aponta para o objeto de janela cuja janela está sendo atualizada.

### <a name="return-value"></a>Valor de retorno

O tipo de região excluído. Ele pode ser qualquer um dos seguintes valores:

- COMPLEXREGION a região tem bordas de sobreposição.

- Erro nenhuma região foi criado.

- NULLREGION a região está vazia.

- A região SIMPLEREGION tem sem bordas sobrepostas.

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

Preenche uma área da superfície de exibição com o pincel atual.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto em que o preenchimento começa.

*y*<br/>
Especifica a coordenada y lógica do ponto em que o preenchimento começa.

*crColor*<br/>
Especifica a cor do limite ou da área a ser preenchido. A interpretação *crColor* depende do valor de *nFillType*.

*nFillType*<br/>
Especifica o tipo de inundação de preenchimento a ser executada. Ele deve ser um dos seguintes valores:

- FLOODFILLBORDER na área de preenchimento é limitada pela cor especificada por *crColor*. Esse estilo é idêntico ao preenchimento executado pelo `FloodFill`.

- FLOODFILLSURFACE na área de preenchimento é definida pela cor especificada por *crColor*. Preenchimento de para fora continua em todas as direções, desde que a cor é encontrada. Esse estilo é útil para preencher as áreas com limites multicoloridos.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; Caso contrário, 0 se o preenchimento não pôde ser concluído, se o ponto fornecido tem o limite de cor especificada pelas *crColor* (se FLOODFILLBORDER foi solicitado), se o ponto fornecido não tem a cor especificada pela *crColor* (se FLOODFILLSURFACE foi solicitado), ou se o ponto está fora da região de recorte.

### <a name="remarks"></a>Comentários

Essa função membro oferece mais flexibilidade do que `FloodFill` porque você pode especificar um tipo de preenchimento no *nFillType*.

Se *nFillType* é definido para FLOODFILLBORDER, a área é considerada como completamente limitado pela cor especificada pela *crColor*. A função começa no ponto especificado por *x* e *y* e preenche todas as direções para o limite de cor.

Se *nFillType* é definido para FLOODFILLSURFACE, a função começa no ponto especificado por *x* e *y* e continua em todas as direções, preenchimento de todas as áreas adjacentes que contém a cor especificada pela *crColor*.

Somente dispositivos que dão suporte ao suporte de tecnologia de exibição de varredura e contextos de dispositivo de memória `ExtFloodFill`. Para obter mais informações, consulte o [GetDeviceCaps](#getdevicecaps) função de membro.

##  <a name="exttextout"></a>  CDC::ExtTextOut

Chame essa função de membro para gravar uma cadeia de caracteres dentro de uma região retangular usando a fonte atualmente selecionada.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da célula do caractere para o primeiro caractere na cadeia de caracteres especificada.

*y*<br/>
Especifica a coordenada y lógica da parte superior da célula do caractere para o primeiro caractere na cadeia de caracteres especificada.

*nOptions*<br/>
Especifica o tipo de retângulo. Esse parâmetro pode ser um, ambos ou nenhum dos seguintes valores:

- ETO_CLIPPED Especifica que o texto é cortado até o retângulo.

- ETO_OPAQUE Especifica que a cor do plano de fundo atual preenche o retângulo. (Você pode definir e consultar a cor de plano de fundo atual com o [SetBkColor](#setbkcolor) e [GetBkColor](#getbkcolor) funções de membro.)

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura que determina as dimensões do retângulo. Esse parâmetro pode ser NULL. Você também pode passar uma [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*lpszString*<br/>
Aponta para a cadeia de caracteres especificada a ser desenhado. Você também pode passar uma [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*lpDxWidths*<br/>
Aponta para uma matriz de valores que indicam a distância entre as origens de células adjacentes de caracteres. Por exemplo, *lpDxWidths*[ *i*] unidades lógicas separará as origens da célula de caractere *i* e caractere célula *i* + 1. Se *lpDxWidths* for NULL, `ExtTextOut` usa o espaçamento padrão entre caracteres.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados ser desenhado.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

A região retangular pode ser opaca (preenchido com a cor de plano de fundo atual), e pode ser uma região de recorte.

Se *nOptions* é 0 e *lpRect* for NULL, a função grava o texto para o contexto de dispositivo sem usar uma região retangular. Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a posição atual quando ele chama `ExtTextOut`, o aplicativo pode chamar o `CDC` função de membro [SetTextAlign](#settextalign) com *nFlags* definido como TA_UPDATECP. Quando esse sinalizador estiver definido, o Windows ignora *x* e *y* em chamadas subsequentes para `ExtTextOut` e usa a posição atual em vez disso. Quando um aplicativo usa TA_UPDATECP para atualizar a posição atual, `ExtTextOut` define a posição atual até o final da linha do texto anterior ou para a posição especificada pelo último elemento da matriz apontada por *lpDxWidths*, o que for maior.

##  <a name="fillpath"></a>  CDC::FillPath

Fecha as figuras abertas no caminho atual e preenche o interior do caminho usando o pincel atual e o modo de preenchimento de polígono.

```
BOOL FillPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Depois que seu interior é preenchido, o caminho é descartado do contexto do dispositivo.

##  <a name="fillrect"></a>  CDC::FillRect

Chame essa função de membro para preencher um retângulo determinado usando o pincel especificado.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura que contém as coordenadas lógicas do retângulo a ser preenchido. Você também pode passar uma [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto para esse parâmetro.

*pBrush*<br/>
Identifica o pincel usado para preencher o retângulo.

### <a name="remarks"></a>Comentários

A função preenche o retângulo completo, incluindo as bordas esquerdas e superior, mas ela não preencher as bordas direita e inferior.

O pincel precisa ao ser criado usando o [CBrush](../../mfc/reference/cbrush-class.md) funções de membro [CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush), [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush), e [CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush), ou recuperada pelo `GetStockObject` função do Windows.

Ao preencher o retângulo especificado, `FillRect` não inclui os lados de direita e inferior do retângulo. GDI preenche um retângulo até, mas não inclui a linha coluna e a parte inferior direita, independentemente do modo de mapeamento atual. `FillRect` compara os valores da `top`, `bottom`, `left`, e `right` membros do retângulo especificado. Se `bottom` é menor que ou igual a `top`, ou se `right` é menor que ou igual a `left`, o retângulo não é desenhado.

`FillRect` é semelhante à [CDC::FillSolidRect](#fillsolidrect); no entanto, `FillRect` usa um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, uma cor pontilhada, pincéis tracejadas ou um padrão. `FillSolidRect` usa apenas cores sólidas (indicadas por um parâmetro COLORREF). `FillRect` geralmente é mais lento do que `FillSolidRect`.

##  <a name="fillrgn"></a>  CDC::FillRgn

Preenche a região especificada por *pRgn* com o pincel especificado por *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Um ponteiro para a região a ser preenchido. As coordenadas para a determinada região são especificadas em unidades lógicas.

*pBrush*<br/>
Identifica o pincel a ser usada para preencher a região.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O pincel deve ser criado usando o `CBrush` funções de membro `CreateHatchBrush`, `CreatePatternBrush`, `CreateSolidBrush`, ou ser recuperada pelo `GetStockObject`.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

Chame essa função de membro para preencher o retângulo fornecido com a cor sólida especificada.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Especifica o retângulo delimitador (em unidades lógicas). Você pode passar um ponteiro para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura de dados ou um `CRect` objeto para esse parâmetro.

*CLR* Especifica a cor a ser usado para preencher o retângulo.

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*cx*<br/>
Especifica a largura do retângulo.

*cy*<br/>
Especifica a altura do retângulo.

### <a name="remarks"></a>Comentários

`FillSolidRect` é muito semelhante à [CDC::FillRect](#fillrect); no entanto, `FillSolidRect` usa apenas cores sólidas (indicadas pelo parâmetro COLORREF), enquanto `FillRect` usa um pincel e, portanto, pode ser usado para preencher um retângulo com uma cor sólida, um pontilhado cores, pincéis tracejadas ou um padrão. `FillSolidRect` geralmente é mais rápido que `FillRect`.

> [!NOTE]
>  Quando você chama `FillSolidRect`, a cor de plano de fundo, que foi anteriormente definida usando [SetBkColor](#setbkcolor), é definido como a cor indicada por *clr*.

##  <a name="flattenpath"></a>  CDC::FlattenPath

Transforma qualquer curvas no caminho selecionado no contexto de dispositivo atual e transforma cada curva em uma sequência de linhas.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="floodfill"></a>  CDC::FloodFill

Preenche uma área da superfície de exibição com o pincel atual.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto em que o preenchimento começa.

*y*<br/>
Especifica a coordenada y lógica do ponto em que o preenchimento começa.

*crColor*<br/>
Especifica a cor do limite.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; Caso contrário, 0 será retornado se o preenchimento não pôde ser concluído, o ponto fornecido tem a cor do limite especificada pelo *crColor*, ou o ponto está fora da região de recorte.

### <a name="remarks"></a>Comentários

A área é considerada ao ser delimitada como especificado por *crColor*. O `FloodFill` função começa no ponto especificado por *x* e *y* e continua em todas as direções para o limite de cor.

Somente dispositivos que dão suporte ao suporte de tecnologia de exibição de varredura e contextos de dispositivo de memória a `FloodFill` função de membro. Para obter informações sobre a funcionalidade de RC_BITBLT, consulte o `GetDeviceCaps` função de membro.

O `ExtFloodFill` função fornece funcionalidade semelhante, mas a maior flexibilidade.

##  <a name="framerect"></a>  CDC::FrameRect

Desenha uma borda ao redor do retângulo especificado por *lpRect*.

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que contém as coordenadas lógicas dos cantos superior esquerdo e direito inferior do retângulo. Você também pode passar um `CRect` objeto para esse parâmetro.

*pBrush*<br/>
Identifica o pincel a ser usado para o retângulo de delimitação de quadros.

### <a name="remarks"></a>Comentários

A função usa o determinado pincel para desenhar a borda. A largura e altura da borda é sempre 1 unidade lógica.

Se o retângulo `bottom` coordenada é menor que ou igual a `top`, ou se `right` é menor que ou igual a `left`, o retângulo não é desenhado.

A borda desenhada pelo `FrameRect` está na mesma posição que uma borda desenhada pelo `Rectangle` usando as mesmas coordenadas de função de membro (se `Rectangle` usa uma caneta de 1 unidade lógica ampla). O interior do retângulo não é preenchido por `FrameRect`.

##  <a name="framergn"></a>  CDC::FrameRgn

Desenha uma borda em torno da região especificada por *pRgn* usando o pincel especificado por *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Aponta para o `CRgn` objeto que identifica a região a ser colocado em uma borda. As coordenadas para a determinada região são especificadas em unidades lógicas.

*pBrush*<br/>
Aponta para o `CBrush` objeto que identifica o pincel a ser usado para desenhar a borda.

*nWidth*<br/>
Especifica a largura da borda em pinceladas vertical em unidades de dispositivo.

*nHeight*<br/>
Especifica a altura da borda em pinceladas horizontal em unidades de dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

##  <a name="fromhandle"></a>  CDC::FromHandle

Retorna um ponteiro para um `CDC` quando é fornecido um identificador para um contexto de dispositivo do objeto.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Contém um identificador para um contexto de dispositivo do Windows.

### <a name="return-value"></a>Valor de retorno

O ponteiro pode ser temporário e não deve ser armazenado além do uso imediato.

### <a name="remarks"></a>Comentários

Se um `CDC` objeto não está anexado ao identificador, um temporário `CDC` objeto é criado e anexado.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

Retorna a direção do arco atual para o contexto de dispositivo.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Valor de retorno

Especifica a direção do arco atual, se for bem-sucedido. A seguir está os valores de retorno válidos:

- AD_COUNTERCLOCKWISE arcos e retângulos desenhados no sentido anti-horário.

- AD_CLOCKWISE arcos e retângulos desenhados no sentido horário.

Se ocorrer um erro, o valor de retorno é zero.

### <a name="remarks"></a>Comentários

Funções de arco e retângulo usam a direção do arco.

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

Recupera a configuração para o filtro de taxa de proporção atual.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Valor de retorno

Um `CSize` objeto que representa a taxa de proporção usada pelo filtro atual de taxa de proporção.

### <a name="remarks"></a>Comentários

A taxa de proporção é a razão formada pela altura e largura de pixel de um dispositivo. Informações sobre a taxa de proporção de um dispositivo são usadas na criação, seleção e exibição de fontes. Windows fornece um filtro especial, o filtro de taxa de proporção, selecionar fontes projetadas para uma determinada taxa de proporção de todas as fontes disponíveis. O filtro usa a taxa de proporção especificada pelo `SetMapperFlags` função de membro.

##  <a name="getbkcolor"></a>  CDC::GetBkColor

Retorna a cor de plano de fundo atual.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Valor de retorno

Um valor de cor RGB.

### <a name="remarks"></a>Comentários

Se o modo de tela de fundo é OPACO, o sistema usa a cor do plano de fundo para preencher as lacunas em linhas com estilo definido, as lacunas entre linhas tracejadas em pincéis e o plano de fundo em células de caractere. O sistema também usa a cor do plano de fundo quando convertendo bitmaps entre cores e contextos de dispositivo monocromático.

##  <a name="getbkmode"></a>  CDC::GetBkMode

Retorna o modo de tela de fundo.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Valor de retorno

O modo de tela de fundo atual, que pode ser OPACA ou TRANSPARENTE.

### <a name="remarks"></a>Comentários

O modo de tela de fundo define se o sistema remove as cores de plano de fundo existentes na superfície de desenho antes do desenho de texto, pincéis tracejadas ou qualquer estilo de caneta que não é uma linha sólida.

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

Retorna o retângulo delimitador acumulado atual para o contexto de dispositivo especificado.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para um buffer que receberá o retângulo delimitador atual. O retângulo é retornado em coordenadas lógicas.

*flags*<br/>
Especifica se o retângulo delimitador a ser limpa depois que ele é retornado. Esse parâmetro deve ser zero ou definido como o seguinte valor:

- DCB_RESET força o retângulo delimitador a ser limpa depois que ele é retornado.

### <a name="return-value"></a>Valor de retorno

Especifica o estado atual do retângulo delimitador se a função for bem-sucedida. Ele pode ser uma combinação dos seguintes valores:

- Acúmulo de retângulo delimitador DCB_ACCUMULATE está ocorrendo.

- Retângulo delimitador DCB_RESET está vazio.

- Retângulo delimitador de DCB_SET não está vazio.

- Acúmulo DCB_ENABLE delimitadora está.

- Acúmulo de delimitação DCB_DISABLE está desativado.

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

Recupera a origem (em unidades de dispositivo) do pincel selecionado atualmente para o contexto de dispositivo.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem atual do pincel (em unidades de dispositivo) como um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto.

### <a name="remarks"></a>Comentários

A origem do pincel inicial está em (0,0) da área de cliente. O valor de retorno especifica esse ponto em unidades de dispositivo relativo à origem da janela da área de trabalho.

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

Recupera vários tipos de informações em uma cadeia de caracteres.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Parâmetros

*lpString*<br/>
Um ponteiro para a cadeia de caracteres para processar.

*nCount*<br/>
Especifica o comprimento da cadeia de caracteres. Para obter a versão ANSI, é uma contagem de bytes e para a função Unicode é uma contagem de PALAVRAS. Para obter mais informações, consulte [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa).

*nMaxExtent*<br/>
Especifica a extensão máxima (em unidades lógicas) para que a cadeia de caracteres é processada. Os caracteres que, se processados, possam exceder essa extensão são ignorados. Cálculos para qualquer necessárias ordenação ou matrizes de glifo se aplicam somente aos caracteres incluídos. Esse parâmetro é usado somente se o valor GCP_MAXEXTENT é especificado na *dwFlags* parâmetro. Como a função processa a cadeia de caracteres de entrada, cada caractere e sua extensão é adicionada para a saída, extensão e outras matrizes somente se a extensão total ainda não excedeu o máximo. Depois que o limite for atingido, o processamento será interrompido.

*lpResults*<br/>
Ponteiro para um [GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa) estrutura que recebe os resultados da função.

*dwFlags*<br/>
Especifica como processar a cadeia de caracteres para as matrizes necessárias. Esse parâmetro pode ser um ou mais dos valores listados na *dwFlags* seção o [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa) tópico.

*str*<br/>
Um ponteiro para um [CString](../../atl-mfc-shared/reference/cstringt-class.md) ao processo do objeto.

### <a name="return-value"></a>Valor de retorno

Se a função for bem-sucedida, o valor de retorno é a largura e altura da cadeia de caracteres em unidades lógicas.

Se a função falhar, o valor retornado será zero.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa), conforme descrito no SDK do Windows.

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

Recupera as larguras de caracteres consecutivos em um intervalo especificado de fonte TrueType atual.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere no intervalo de caracteres da fonte atual para o qual as larguras de caracteres são retornadas.

*nLastChar*<br/>
Especifica o último caractere no intervalo de caracteres da fonte atual para o qual as larguras de caracteres são retornadas.

*lpabc*<br/>
Aponta para uma matriz de [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) estruturas que recebem as larguras de caracteres quando a função retorna. Essa matriz deve conter pelo menos tantos `ABC` estruturas como há caracteres no intervalo especificado pelo *nFirstChar* e *nLastChar* parâmetros.

*lpABCF*<br/>
Aponta para um buffer de aplicativo fornecido com uma matriz de [ABCFLOAT](/windows/desktop/api/wingdi/ns-wingdi-_abcfloat) estruturas para receber as larguras de caracteres quando a função retorna. As larguras retornadas por essa função estão no formato de ponto flutuante IEEE.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As larguras são retornadas em unidades lógicas. Essa função terá êxito apenas com as fontes TrueType.

O rasterizador de TrueType fornece espaçamento de caracteres "ABC" depois que um tamanho de ponto específico tiver sido selecionado. "A" espaçamento é a distância que é adicionada à posição atual antes de colocar o glifo. Espaçamento de "B" é a largura da parte preta de glifo. Espaçamento de "C" é adicionado à posição atual para levar em conta o espaço em branco à direita do glifo. Advanced largura total é dado por um + B + C.

Quando o `GetCharABCWidths` função de membro recupera negativa "A" ou "C" larguras de um caractere, esse caractere inclui underhangs ou overhangs.

Para converter as larguras de ABC para unidades de design de fonte, um aplicativo deve criar uma fonte cuja altura (conforme especificado na `lfHeight` membro do [LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta) estrutura) é igual ao valor armazenado no `ntmSizeEM` membro o [ NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica) estrutura. (O valor da `ntmSizeEM` membro pode ser recuperado chamando o [EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) função do Windows.)

As larguras de ABC do caractere padrão são usadas para os caracteres que estão fora do intervalo da fonte atualmente selecionada.

Para recuperar as larguras de caracteres em outras fontes, os aplicativos devem usar o [GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) função do Windows.

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

Recupera as larguras, em unidades lógicas, consecutivos de índices de glifo em um intervalo especificado de fonte TrueType atual.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice do glifo no grupo de índices de glifo consecutivos da fonte atual. Esse parâmetro é usado somente se o *pgi* parâmetro for nulo.

*cgi*<br/>
Especifica o número de índices de glifo.

*pgi*<br/>
Um ponteiro para uma matriz que contém os índices de glifo. Se o valor for NULL, o *giFirst* parâmetro é usado em vez disso. O *cgi* parâmetro especifica o número de índices de glifo nesta matriz.

*lpabc*<br/>
Ponteiro para uma matriz de [ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc) estruturas recebendo as larguras de caracteres. Essa matriz deve conter pelo menos tantos `ABC` estruturas como há índices de glifo especificados pelo *cgi* parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi), conforme descrito no SDK do Windows.

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

Recupera as larguras de caracteres individuais em um grupo de caracteres consecutivos da fonte atual, usando `m_hAttribDC`, o contexto de dispositivo de entrada.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere em um grupo de caracteres na fonte atual consecutivos.

*nLastChar*<br/>
Especifica o último caractere em um grupo de caracteres na fonte atual consecutivos.

*lpBuffer*<br/>
Aponta para um buffer que receberá os valores de largura de um grupo de caracteres consecutivos na fonte atual.

*lpFloatBuffer*<br/>
Aponta para um buffer para recebimento de larguras de caracteres. As larguras retornadas estão no formato de ponto flutuante IEEE de 32 bits. (As larguras são medidas ao longo da linha de base de dados de caracteres).

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identifica a letra 'a' e *nLastChar* identifica a letra 'z', a função recupera as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontado por *lpBuffer*. Este buffer deve ser grande o suficiente para conter todas as larguras. Ou seja, deve haver pelo menos 26 entradas no exemplo dado.

Se não existir um caractere no grupo de caracteres consecutivo em uma determinada fonte, ele será atribuído o valor da largura do caractere padrão.

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

Recupera as larguras, em coordenadas lógicas, consecutivos de índices de glifo em um intervalo especificado da fonte atual.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*giFirst*<br/>
Especifica o primeiro índice do glifo no grupo de índices de glifo consecutivos da fonte atual. Esse parâmetro é usado somente se o *pgi* parâmetro for nulo.

*cgi*<br/>
Especifica o número de índices de glifo.

*pgi*<br/>
Um ponteiro para uma matriz que contém os índices de glifo. Se o valor for NULL, o *giFirst* parâmetro é usado em vez disso. O *cgi* parâmetro especifica o número de índices de glifo nesta matriz.

*lpBuffer*<br/>
Um ponteiro para um buffer que recebe as larguras.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi), conforme descrito no SDK do Windows.

##  <a name="getclipbox"></a>  CDC::GetClipBox

Recupera as dimensões do retângulo delimitador tightest em torno do limite de recorte atual.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para o [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto que receberá as dimensões do retângulo.

### <a name="return-value"></a>Valor de retorno

Tipo da região de recorte. Ele pode ser qualquer um dos seguintes valores:

- Região de recorte COMPLEXREGION tem bordas de sobreposição.

- Contexto de dispositivo de erro não é válido.

- Região de recorte NULLREGION está vazia.

- Região de recorte SIMPLEREGION tem sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

As dimensões são copiadas para o buffer apontado por *lpRect*.

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

Recupera os valores de ajuste de cor para o contexto de dispositivo.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para um [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment) estrutura de dados para receber os valores de ajuste de cor.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

Retorna um ponteiro para selecionado no momento `CBitmap` objeto.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CBitmap` objeto, se for bem-sucedido; caso contrário, nulo.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

Retorna um ponteiro para selecionado no momento `CBrush` objeto.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CBrush` objeto, se for bem-sucedido; caso contrário, nulo.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

Retorna um ponteiro para selecionado no momento `CFont` objeto.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CFont` objeto, se for bem-sucedido; caso contrário, nulo.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

Retorna um ponteiro para selecionado no momento `CPalette` objeto.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CPalette` objeto, se for bem-sucedido; caso contrário, nulo.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

Retorna um ponteiro para selecionado no momento `CPen` objeto.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CPen` objeto, se for bem-sucedido; caso contrário, nulo.

### <a name="remarks"></a>Comentários

Essa função de membro pode retornar objetos temporários.

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

Recupera a posição atual (em coordenadas lógicas).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Valor de retorno

A posição atual como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

A posição atual pode ser definida com o `MoveTo` função de membro.

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

Recupera a cor atual do pincel.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Valor de retorno

Se a função for bem-sucedida, o valor retornado é o [COLORREF](/windows/desktop/gdi/colorref) valor para a cor atual do pincel.

Se a função falhar, o valor de retorno é CLR_INVALID.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor), conforme descrito no SDK do Windows.

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

Recupera a cor atual da caneta.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Valor de retorno

Se a função for bem-sucedida, o valor retornado é o [COLORREF](/windows/desktop/gdi/colorref) valor para a cor da caneta atual.

Se a função falhar, o valor de retorno é CLR_INVALID.

### <a name="remarks"></a>Comentários

Essa função membro utiliza a função Win32 [GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor), conforme descrito no SDK do Windows.

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

Recupera uma ampla variedade de informações específicas de dispositivo sobre o dispositivo de vídeo.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de informação a ser retornada. Ver [GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) no SDK do Windows para obter uma lista de valores.

### <a name="return-value"></a>Valor de retorno

O valor do recurso solicitado se a função for bem-sucedida.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

##  <a name="getfontdata"></a>  CDC::GetFontData

Recupera informações de métrica de fonte de um arquivo de fonte escalonável.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Parâmetros

*dwTable*<br/>
Especifica o nome da tabela de métricas a serem retornados. Esse parâmetro pode ser uma das tabelas de métricas documentadas na especificação de arquivos de fonte TrueType, publicada pela Microsoft Corporation. Se esse parâmetro for 0, as informações são recuperadas desde o início do arquivo fonte.

*dwOffset*<br/>
Especifica o deslocamento do início da tabela na qual iniciar a recuperação de informações. Se esse parâmetro for 0, as informações são recuperadas desde o início da tabela especificada o *dwTable* parâmetro. Se esse valor for maior que ou igual ao tamanho da tabela, `GetFontData` retornará 0.

*lpData*<br/>
Aponta para um buffer que receberá as informações de fonte. Se esse valor for NULL, a função retorna o tamanho do buffer exigido para os dados de fonte especificados na *dwTable* parâmetro.

*cbData*<br/>
Especifica o comprimento, em bytes, das informações a serem recuperados. Se esse parâmetro for 0, `GetFontData` retorna o tamanho dos dados especificados em de *dwTable* parâmetro.

### <a name="return-value"></a>Valor de retorno

Especifica o número de bytes retornados no buffer apontado por *lpData* se a função for bem-sucedida; caso contrário -1.

### <a name="remarks"></a>Comentários

As informações a serem recuperadas são identificadas, especificando um deslocamento para o arquivo de fonte e o tamanho das informações para retornar.

Um aplicativo, às vezes, pode usar o `GetFontData` a função de membro para salvar uma fonte TrueType com um documento. Para fazer isso, o aplicativo determina se a fonte pode ser inserida e, em seguida, recupere o arquivo de fonte inteira, especificar 0 para o *dwTable*, *dwOffset*, e *cbData* parâmetros.

Os aplicativos podem determinar se uma fonte pode ser incorporada, verificando o `otmfsType` membro a [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) estrutura. Se o bit 1 do `otmfsType` estiver definido, a inserção não é permitida para a fonte. Se o bit 1 estiver desmarcado, a fonte pode ser incorporada. Se o bit 2 estiver definido, a inserção é somente leitura.

Se um aplicativo tentar usar essa função para recuperar informações para uma fonte não-TrueType, o `GetFontData` função membro retorna -1.

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

Retorna informações sobre a fonte atualmente selecionada para o contexto de exibição especificado.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno identifica as características da fonte selecionada no momento. Para obter uma lista completa de valores possíveis, consulte [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo).

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo), conforme descrito no SDK do Windows.

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

Recupera a curva de estrutura de tópicos ou de bitmap para um caractere de estrutura de tópicos na fonte atual.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Parâmetros

*nChar*<br/>
Especifica o caractere para o qual informações deve ser retornado.

*nFormat*<br/>
Especifica o formato no qual a função é retornar informações. Ele pode ser um dos valores a seguir, ou 0:

|Valor|Significado|
|-----------|-------------|
|GGO_BITMAP|Retorna o bitmap de glifo. Quando a função retornar, o buffer apontado por *lpBuffer* contém um bitmap de 1 bit por pixel cujas linhas Iniciar em limites de palavras duplas.|
|GGO_NATIVE|Retorna a curva de pontos de dados em formato nativo do rasterizador, uso de unidades de dispositivo. Quando esse valor for especificado, qualquer transformação especificado na *lpmat2* será ignorado.|

Quando o valor de *nFormat* for 0, a função preenche uma [GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics) estrutura, mas não retorna dados de contorno do glifo.

*lpgm*<br/>
Aponta para uma estrutura GLYPHMETRICS que descreve o posicionamento de glifo na célula do caractere.

*cbBuffer*<br/>
Especifica o tamanho do buffer para a qual a função copia informações sobre o caractere de estrutura de tópicos. Se esse valor é 0 e o *nFormat* parâmetro é o GGO_BITMAP ou GGO_NATIVE valores, a função retorna o tamanho necessário do buffer.

*lpBuffer*<br/>
Aponta para um buffer para a qual a função copia informações sobre o caractere de estrutura de tópicos. Se *nFormat* Especifica o valor GGO_NATIVE, as informações são copiadas na forma de TTPOLYGONHEADER e TTPOLYCURVE estruturas. Se esse valor for NULL e *nFormat* é GGO_BITMAP ou GGO_NATIVE valor, a função retorna o tamanho necessário do buffer.

*lpmat2*<br/>
Aponta para um [MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2) estrutura que contém uma matriz de transformação do caractere. Esse parâmetro não pode ser NULL, mesmo quando o valor GGO_NATIVE é especificado para *nFormat*.

### <a name="return-value"></a>Valor de retorno

O tamanho, em bytes, do buffer exigido para as informações recuperadas se *cbBuffer* for 0 ou *lpBuffer* é NULL. Caso contrário, ele é um valor positivo se a função for bem-sucedida, ou -1 se não houver um erro.

### <a name="remarks"></a>Comentários

Um aplicativo pode girar caracteres recuperados no formato de bitmap especificando uma matriz de transformação de 2 a 2 na estrutura apontada por *lpmat2*.

Um contorno do glifo é retornado como uma série de contorno. Cada contorno é definido por uma [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) structure seguida por tantas `TTPOLYCURVE` estruturas forem necessárias para descrevê-lo. Todos os pontos são retornados como [POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx) estruturas e representar posições absolutas, move não relativo. O ponto de início fornecido pela `pfxStart` membro do [TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader) estrutura é o ponto em que a estrutura de tópicos para a delimitação começa. O [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve) estruturas a seguirem podem ser polilinha registros ou registros de spline. Registros de polilinha são uma série de pontos; as linhas desenhadas entre os pontos de descrevem o contorno do caractere. Registros de spline representam as curvas quadráticas usadas pelo TrueType (ou seja, quadrática de b-splines).

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

Recupera o modo de gráfico atual para o contexto de dispositivo especificado.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Valor de retorno

Retorna o modo gráfico atual em caso de sucesso. Para obter uma lista dos valores de que esse método pode retornar, consulte [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

Retorna 0 em caso de falha.

Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Esse método encapsula a função do Windows GDI [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode).

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

Chame essa função de membro para recuperar um pincel de meio-tom.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Valor de retorno

Um ponteiro para um `CBrush` objeto se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Um pincel de meio-tom mostra os pixels como alternativa, cores de primeiro plano e plano de fundo para criar um padrão de pontilhado. O exemplo a seguir é um exemplo de um padrão de pontilhado criado por um pincel de meio-tom.

![Detalhes de um traço de caneta pontilhado](../../mfc/reference/media/vc318s1.gif "detalhes de um traço de caneta pontilhado")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

Recupera o caractere kerning de pares para a fonte atualmente selecionada no contexto de dispositivo especificado.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Parâmetros

*nPairs*<br/>
Especifica o número de [KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair) estruturas apontado por *lpkrnpair*. A função não copiará mais pares de ajuste de espaço que o especificado por *nPairs*.

*lpkrnpair*<br/>
Aponta para uma matriz de `KERNINGPAIR` estruturas que recebem o kerning de pares quando a função retorna. Essa matriz deve conter pelo menos o mesmo número de estruturas conforme especificado pelo *nPairs*. Se esse parâmetro for NULL, a função retorna o número total de kerning de pares para a fonte.

### <a name="return-value"></a>Valor de retorno

Especifica o número de pares recuperados o kerning ou o número total de kerning pares na fonte, se a função for bem-sucedida. Zero será retornado se a função falhar ou se não há nenhum par kerning para a fonte.

##  <a name="getlayout"></a>  CDC::GetLayout

Chame essa função de membro para determinar o layout do texto e elementos gráficos para um contexto de dispositivo, como uma impressora ou um metarquivo.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, o layout sinaliza para o contexto de dispositivo atual. Caso contrário, GDI_ERROR. Para obter informações estendidas de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360). Para obter uma lista dos sinalizadores de layout, consulte [CDC::SetLayout](#setlayout).

### <a name="remarks"></a>Comentários

O layout padrão é da esquerda para a direita.

##  <a name="getmapmode"></a>  CDC::GetMapMode

Recupera o modo de mapeamento atual.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Valor de retorno

O modo de mapeamento.

### <a name="remarks"></a>Comentários

Para obter uma descrição dos modos de mapeamento, consulte o `SetMapMode` função de membro.

> [!NOTE]
>  Se você chamar [SetLayout](#setlayout) para alterar o controlador de domínio para o layout da direita para esquerda, `SetLayout` automaticamente altera o modo de mapeamento para MM_ISOTROPIC. Consequentemente, qualquer chamada subsequente para `GetMapMode` retornará MM_ISOTROPIC.

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

Retorna o limite de Malhete para o contexto de dispositivo.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O limite de Malhete é usado quando o desenho geométricas linhas com junções de Malhete.

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

Retorna a cor sólida que melhor corresponde a uma cor de lógica especificada.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a cor a ser correspondido.

### <a name="return-value"></a>Valor de retorno

Um valor de cor RGB (vermelho, verde, azul) que define sólido de cor mais próxima para o *crColor* valor que o dispositivo pode representar.

### <a name="remarks"></a>Comentários

O dispositivo fornecido deve ser capaz de representar essa cor.

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

Recupera informações de métrica para as fontes TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Parâmetros

*lpotm*<br/>
Aponta para uma matriz de [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) estruturas. Se esse parâmetro for NULL, a função retorna o tamanho do buffer exigido para os dados recuperados de métrica.

*cbData*<br/>
Especifica o tamanho, em bytes, do buffer para o qual as informações são retornadas.

*lpotm*<br/>
Aponta para um `OUTLINETEXTMETRIC` estrutura. Se esse parâmetro for NULL, a função retorna o tamanho do buffer exigido para as informações recuperadas de métrica.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O [OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica) estrutura contém a maioria das informações de métrica de fonte fornecidas com o formato TrueType, incluindo um [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) estrutura. Os últimos quatro membros do `OUTLINETEXTMETRIC` estrutura são ponteiros para cadeias de caracteres. Aplicativos devem alocar espaço para essas cadeias de caracteres além do espaço necessário para os outros membros. Porque não há nenhum limite imposto pelo sistema para o tamanho das cadeias de caracteres, o método mais simples para alocar a memória é recuperar o tamanho necessário ao especificar NULL para *lpotm* na primeira chamada para o `GetOutlineTextMetrics` função.

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

Usa o contexto de dispositivo de saída, `m_hDC`e recupera as larguras de caracteres individuais em um grupo de caracteres consecutivos de fonte atual.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Parâmetros

*nFirstChar*<br/>
Especifica o primeiro caractere em um grupo de caracteres na fonte atual consecutivos.

*nLastChar*<br/>
Especifica o último caractere em um grupo de caracteres na fonte atual consecutivos.

*lpBuffer*<br/>
Aponta para um buffer que receberá os valores de largura de um grupo de caracteres consecutivos na fonte atual.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Por exemplo, se *nFirstChar* identifica a letra 'a' e *nLastChar* identifica a letra 'z', a função recupera as larguras de todos os caracteres minúsculos.

A função armazena os valores no buffer apontado por *lpBuffer*. Esse buffer deve ser grande o suficiente para conter todas as larguras; ou seja, deve haver pelo menos 26 entradas no exemplo dado.

Se não existir um caractere no grupo de caracteres consecutivo em uma determinada fonte, ele será atribuído o valor da largura do caractere padrão.

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

Chame essa função de membro para calcular a largura e altura de uma cadeia de caracteres usando [m_hDC](#m_hdc), o contexto de dispositivo de saída.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres a ser medido. Você também pode passar uma [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, o comprimento será calculado.

*nTabPositions*<br/>
Especifica o número de posições de parada de tabulação na matriz apontada por *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Aponta para uma matriz de inteiros que contém as posições de parada de tabulação em unidades lógicas. As paradas de tabulação devem ser classificadas em ordem; crescente o menor valor de x deve ser o primeiro item na matriz. Guias de back-não são permitidas.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidas.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

Se a cadeia de caracteres contiver um ou mais caracteres de tabulação, a largura da cadeia de caracteres baseia as paradas de tabulação especificadas por *lpnTabStopPositions*. A função usa a fonte atualmente selecionada para calcular as dimensões da cadeia de caracteres.

A região de recorte atual não desloca a largura e altura retornado pelo `GetOutputTabbedTextExtent` função.

Uma vez que alguns dispositivos não posicionar caracteres nas matrizes de célula regulares (ou seja, eles kerning de caracteres), a soma das extensões dos caracteres em uma cadeia de caracteres não pode ser igual a extensão da cadeia de caracteres.

Se *nTabPositions* é 0 e *lpnTabStopPositions* for NULL, as guias são expandidas para oito larguras de caracteres média. Se *nTabPositions* é 1, as paradas de tabulação serão separadas pela distância especificada pelo primeiro valor na matriz para o qual *lpnTabStopPositions* pontos. Se *lpnTabStopPositions* aponta para mais de um único valor, uma parada de tabulação é definida para cada valor na matriz, até o número especificado por *nTabPositions*.

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

Chame essa função de membro para usar o contexto de dispositivo de saída [m_hDC](#m_hdc)e calcular a largura e altura de uma linha de texto, usando a fonte atual.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar uma [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, o comprimento será calculado.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados a serem medidas.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) retornadas em uma [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

A região de recorte atual não afeta a largura e altura retornado por `GetOutputTextExtent`.

Uma vez que alguns dispositivos não posicionar caracteres nas matrizes de célula regulares (ou seja, eles realizarem kerning), a soma das extensões dos caracteres em uma cadeia de caracteres não pode ser igual a extensão da cadeia de caracteres.

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

Recupera as métricas para a fonte atual usando `m_hDC`, o contexto de dispositivo de saída.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para o [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) estrutura que recebe as métricas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getpath"></a>  CDC::GetPath

Recupera as coordenadas definindo os pontos de extremidade de linhas e pontos de controle de curvas encontrados no caminho que está selecionado no contexto de dispositivo.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas de dados ou `CPoint` objetos em que os pontos de extremidade de linha e a curva de pontos de controle são colocados.

*lpTypes*<br/>
Aponta para uma matriz de bytes em que os tipos de vértice são colocados. Os valores são um dos seguintes:

- PT_MOVETO Especifica que correspondente point-in *lpPoints* inicia uma figura não contíguo.

- Especifica que ponto o ponto anterior e correspondentes no, PT_LINETO *lpPoints* são os pontos de extremidade de uma linha.

- PT_BEZIERTO Especifica que correspondente point-in *lpPoints* é um ponto de controle ou o ponto final de uma curva Bzier.

Tipos PT_BEZIERTO sempre ocorrem em conjuntos de três. O ponto no caminho imediatamente, precedendo-as define o ponto de partida da curva Bzier. Os primeiros dois pontos PT_BEZIERTO são os pontos de controle e o terceiro ponto PT_BEZIERTO é o ponto de extremidade (se embutido em código).

   Um tipo PT_LINETO ou PT_BEZIERTO pode ser combinado com o seguinte sinalizador (usando o operador bit a bit **OR**) para indicar que o ponto correspondente é o último ponto em uma figura e que a figura deve ser fechada:

- PT_CLOSEFIGURE Especifica que a figura está fechada automaticamente após a linha correspondente ou curva é desenhada. A figura está fechada desenhando uma linha do ponto de extremidade de linha ou curva ao ponto correspondente ao último PT_MOVETO.

*nCount*<br/>
Especifica o número total de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas de dados que podem ser colocadas na *lpPoints* matriz. Esse valor deve ser o mesmo que o número de bytes que pode ser colocado na *lpTypes* matriz.

### <a name="return-value"></a>Valor de retorno

Se o *nCount* parâmetro é diferente de zero, o número de pontos enumerados. Se *nCount* é 0, o número total de pontos no caminho (e `GetPath` buffers não grava nada). Se *nCount* é diferente de zero e é menor que o número de pontos no caminho, o valor retornado será -1.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. Os pontos do caminho são retornados em coordenadas lógicas. Pontos são armazenados no caminho nas coordenadas do dispositivo, portanto, `GetPath` altera os pontos de coordenadas do dispositivo para coordenadas lógicas usando o inverso da transformação atual. O `FlattenPath` função de membro pode ser chamada antes de `GetPath`, converter todas as curvas no caminho em segmentos de linha.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC:: beginpath](#beginpath).

##  <a name="getpixel"></a>  CDC::GetPixel

Recupera o valor de cor RGB do pixel no ponto especificado por *x* e *y*.

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser examinado.

*y*<br/>
Especifica a coordenada y lógica do ponto a ser examinado.

*point*<br/>
Especifica a lógica coordenadas x e y-do ponto a ser examinado.

### <a name="return-value"></a>Valor de retorno

Independentemente da versão da função, um valor de cor RGB da cor de um determinado ponto. Ele é -1 se as coordenadas não especificar um ponto na região de recorte.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte. Se o ponto não estiver na região de recorte, a função não tem nenhum efeito e retorna -1.

Nem todos os dispositivos oferecem suporte à função `GetPixel`. Para obter mais informações, consulte o recurso de varredura RC_BITBLT sob o [GetDeviceCaps](#getdevicecaps) função de membro.

O `GetPixel` função de membro tem dois formatos. O primeiro usa dois valores de coordenada; a segunda utiliza um uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto.

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

Recupera o modo de preenchimento de polígono atual.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Valor de retorno

O polígono preenchido modo atual, alternativo ou ENROLAMENTO, se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

Consulte o `SetPolyFillMode` a função de membro para obter uma descrição dos modos de preenchimento de polígono.

##  <a name="getrop2"></a>  CDC::GetROP2

Recupera o modo de desenho atual.

```
int GetROP2() const;
```

### <a name="return-value"></a>Valor de retorno

O modo de desenho. Para obter uma lista dos valores de modo de desenho, consulte o `SetROP2` função de membro.

### <a name="remarks"></a>Comentários

O modo de desenho Especifica como as cores da caneta e o interior de objetos preenchidos são combinadas com a cor já na superfície de exibição.

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

Chame essa função de membro para obter [m_hDC](#m_hdc), o contexto de dispositivo de saída.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Valor de retorno

Um identificador de contexto de dispositivo.

### <a name="remarks"></a>Comentários

Essa função de membro também funciona com ponteiros nulos.

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

Recupera o modo atual de alongamento de bitmap.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno Especifica o modo de alongamento de bitmap atual — STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS — se a função for bem-sucedida.

### <a name="remarks"></a>Comentários

O modo de alongamento de bitmap define como as informações são removidas do bitmaps que são alongados ou compactados com o `StretchBlt` função de membro.

Os modos de STRETCH_ANDSCANS e STRETCH_ORSCANS normalmente são usados para preservar os pixels do primeiro plano em bitmaps monocromático. O modo STRETCH_DELETESCANS normalmente é usado para preservar a cor em cor bitmaps.

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

Chame essa função de membro para calcular a largura e altura de uma cadeia de caracteres usando [m_hAttribDC](#m_hattribdc), o contexto de dispositivo do atributo.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar uma [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, o comprimento será calculado.

*nTabPositions*<br/>
Especifica o número de posições de parada de tabulação na matriz apontada por *lpnTabStopPositions*.

*lpnTabStopPositions*<br/>
Aponta para uma matriz de inteiros que contém as posições de parada de tabulação em unidades lógicas. As paradas de tabulação devem ser classificadas em ordem; crescente o menor valor de x deve ser o primeiro item na matriz. Guias de back-não são permitidas.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados ser desenhado.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

Se a cadeia de caracteres contiver um ou mais caracteres de tabulação, a largura da cadeia de caracteres baseia as paradas de tabulação especificadas por *lpnTabStopPositions*. A função usa a fonte atualmente selecionada para calcular as dimensões da cadeia de caracteres.

A região de recorte atual não desloca a largura e altura retornado pelo `GetTabbedTextExtent` função.

Uma vez que alguns dispositivos não posicionar caracteres nas matrizes de célula regulares (ou seja, eles kerning de caracteres), a soma das extensões dos caracteres em uma cadeia de caracteres não pode ser igual a extensão da cadeia de caracteres.

Se *nTabPositions* é 0 e *lpnTabStopPositions* for NULL, as guias são expandidas para oito vezes a média largura do caractere. Se *nTabPositions* é 1, as paradas de tabulação serão separadas pela distância especificada pelo primeiro valor na matriz para o qual *lpnTabStopPositions* pontos. Se *lpnTabStopPositions* aponta para mais de um único valor, uma parada de tabulação é definida para cada valor na matriz, até o número especificado por *nTabPositions*.

##  <a name="gettextalign"></a>  CDC::GetTextAlign

Recupera o status dos sinalizadores de alinhamento de texto para o contexto de dispositivo.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Valor de retorno

O status dos sinalizadores de alinhamento de texto. O valor de retorno é um ou mais dos seguintes valores:

- TA_BASELINE Especifica o alinhamento do eixo x e a linha de base da fonte escolhida dentro do retângulo delimitador.

- TA_BOTTOM Especifica o alinhamento do eixo x e a parte inferior do retângulo delimitador.

- TA_CENTER Especifica o alinhamento do eixo y e o centro do retângulo delimitador.

- TA_LEFT Especifica o alinhamento do eixo y e o lado esquerdo do retângulo delimitador.

- TA_NOUPDATECP Especifica que a posição atual não é atualizada.

- TA_RIGHT Especifica o alinhamento do eixo y e à direita do retângulo delimitador.

- TA_TOP Especifica o alinhamento do eixo x e a parte superior do retângulo delimitador.

- TA_UPDATECP Especifica que a posição atual está atualizada.

### <a name="remarks"></a>Comentários

Determinam os sinalizadores de alinhamento de texto como o `TextOut` e `ExtTextOut` funções de membro alinham uma cadeia de caracteres de texto em relação ao ponto de partida da cadeia de caracteres. Os sinalizadores de alinhamento de texto não são sinalizadores de bit único necessariamente e podem ser iguais a 0. Para testar se um sinalizador é definido, um aplicativo deve seguir estas etapas:

1. Aplica o operador OR bit a bit para o sinalizador e seus sinalizadores relacionados, agrupadas da seguinte maneira:

    - TA_LEFT, TA_CENTER e TA_RIGHT

    - TA_BASELINE, TA_BOTTOM e TA_TOP

    - TA_NOUPDATECP e TA_UPDATECP

1. Aplicar o bit a bit- e operador para o resultado e o valor de retorno `GetTextAlign`.

1. Testar a igualdade esse resultado e o sinalizador.

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

Recupera a configuração atual para a quantidade de espaçamento intercharacter.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Valor de retorno

A quantidade de espaçamento intercharacter.

### <a name="remarks"></a>Comentários

GDI adiciona esse espaçamento para cada caractere, incluindo caracteres de quebra, ao gravar uma linha de texto para o contexto de dispositivo.

O valor padrão para a quantidade de espaçamento intercharacter é 0.

##  <a name="gettextcolor"></a>  CDC::GetTextColor

Recupera a cor do texto atual.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Valor de retorno

A cor do texto como um valor de cor RGB.

### <a name="remarks"></a>Comentários

A cor do texto é a cor de primeiro plano dos caracteres desenhado usando as funções de membro de saída de texto GDI [TextOut](#textout), [ExtTextOut](#exttextout), e [TabbedTextOut](#tabbedtextout).

##  <a name="gettextextent"></a>  CDC::GetTextExtent

Chame essa função de membro para calcular a largura e altura de uma linha de texto usando a fonte atual para determinar as dimensões.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Parâmetros

*lpszString*<br/>
Aponta para uma cadeia de caracteres. Você também pode passar uma [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) em um [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

As informações são recuperadas do [m_hAttribDC](#m_hattribdc), o contexto de dispositivo do atributo.

Por padrão, `GetTextExtent` pressupõe que o texto para o qual ele recupera a dimensão é definido ao longo de uma linha horizontal (ou seja, o escape é 0). Se você criar uma fonte especificando um escape diferente de zero, você deve converter o ângulo do texto explicitamente para obter as dimensões da cadeia de caracteres.

A região de recorte atual não afeta a largura e altura retornado por `GetTextExtent`.

Uma vez que alguns dispositivos não posicionar caracteres nas matrizes de célula regulares (ou seja, eles realizarem kerning), a soma das extensões dos caracteres em uma cadeia de caracteres não pode ser igual a extensão da cadeia de caracteres.

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

Recupera o número de caracteres em uma cadeia de caracteres especificada que caiba dentro de um espaço especificado e preenche uma matriz com a extensão do texto para cada um desses caracteres.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*pgiIn*<br/>
Um ponteiro para uma matriz de índices de glifo para o qual as extensões devem ser recuperadas.

*cgi*<br/>
Especifica o número de glifos na matriz apontada por *pgiIn*.

*nMaxExtent*<br/>
Especifica a largura máxima permitida, em unidades lógicas, da cadeia de caracteres formatada.

*lpnFit*<br/>
Um ponteiro para um inteiro que recebe uma contagem do número máximo de caracteres que caberá no espaço especificado por *nMaxExtent*. Quando *lpnFit* for NULL, *nMaxExtent* será ignorado.

*alpDx*<br/>
Um ponteiro para uma matriz de inteiros que recebe as extensões de glifo parcial. Cada elemento na matriz fornece a distância, em unidades lógicas, entre o início da matriz de índices de glifo e de glifos que se encaixa no espaço especificado por *nMaxExtent*. Embora essa matriz deve ter pelo menos tantos elementos como índices de glifo especificados por *cgi*, a função preenche a matriz com as extensões apenas para índices de glifo tantos conforme são especificadas por *lpnFit*. Se *lpnDx* for NULL, a função não calcula as larguras de cadeia de caracteres parcial.

*lpSize*<br/>
Ponteiro para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura que recebe as dimensões da matriz de índices de glifo, em unidades lógicas. Esse valor não pode ser NULL.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi), conforme descrito no SDK do Windows.

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

Recupera a largura e altura da matriz especificada de índices de glifo.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*pgiIn*<br/>
Um ponteiro para uma matriz de índices de glifo para o qual as extensões devem ser recuperadas.

*cgi*<br/>
Especifica o número de glifos na matriz apontada por *pgiIn*.

*lpSize*<br/>
Ponteiro para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura que recebe as dimensões da matriz de índices de glifo, em unidades lógicas. Esse valor não pode ser NULL.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função membro emula a funcionalidade da função [GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi), conforme descrito no SDK do Windows.

##  <a name="gettextface"></a>  CDC::GetTextFace

Chame essa função de membro para copiar o nome de face de tipos da fonte atual em um buffer.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Parâmetros

*nCount*<br/>
Especifica o tamanho do buffer (em bytes). Se o nome de face de tipos é maior que o número de bytes especificado por esse parâmetro, o nome será truncado.

*lpszFacename*<br/>
Aponta para o buffer para o nome de face de tipos.

*rString*<br/>
Uma referência a um [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto.

### <a name="return-value"></a>Valor de retorno

O número de bytes copiados para o buffer, não incluindo o caractere nulo de terminação. Ele é 0, se ocorrer um erro.

### <a name="remarks"></a>Comentários

O nome de face de tipos é copiado como uma cadeia de caracteres terminada em nulo.

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

Recupera as métricas para a fonte atual usando o contexto de dispositivo do atributo.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Parâmetros

*lpMetrics*<br/>
Aponta para o [TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica) estrutura que recebe as métricas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="getviewportext"></a>  CDC::GetViewportExt

Recupera as extensões x e y do visor do contexto de dispositivo.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Valor de retorno

A x - e y-extensões (em unidades de dispositivo) como um `CSize` objeto.

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

Recupera as coordenadas x e y da origem do visor associado com o contexto de dispositivo.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem do visor (nas coordenadas do dispositivo) como um `CPoint` objeto.

##  <a name="getwindow"></a>  CDC::GetWindow

Retorna a janela associada ao contexto de dispositivo de exibição.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Valor de retorno

Ponteiro para um `CWnd` objeto se for bem-sucedido; caso contrário, NULL.

### <a name="remarks"></a>Comentários

Essa é uma função avançada. Por exemplo, esta função de membro não pode retornar a janela de exibição ao imprimir ou na visualização de impressão. Ele sempre retorna a janela associada a saída. Funções de saída que usam o controlador de domínio fornecido desenhar nessa janela.

##  <a name="getwindowext"></a>  CDC::GetWindowExt

Recupera as extensões x e y da janela associada ao contexto de dispositivo.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Valor de retorno

A x - e y-extensões (em unidades lógicas) como um `CSize` objeto.

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

Recupera as coordenadas x e y da origem da janela associada ao contexto de dispositivo.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Valor de retorno

A origem da janela (em coordenadas lógicas) como um `CPoint` objeto.

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

Recupera o espaço de mundo atual para transformação de espaço da página.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a um [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) estrutura que recebe o espaço de mundo atual para transformação de espaço da página.

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de sucesso.

Retorna 0 em caso de falha.

Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Esse método encapsula a função do Windows GDI [GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform).

##  <a name="gradientfill"></a>  CDC::GradientFill

Chame essa função de membro para preencher o retângulo e triângulo estruturas com uma cor que passa suavemente de um lado para outro.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Parâmetros

*pVertices*<br/>
Ponteiro para uma matriz de [TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex) estruturas que define um vértice do triângulo.

*nVertices*<br/>
O número de vértices.

*pMesh*<br/>
Matriz de [GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle) no modo de triângulo ou uma matriz de estruturas de [GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect) estruturas no modo do retângulo.

*nMeshElements*<br/>
O número de elementos (triângulos ou retângulos) no *pMesh*.

*dwMode*<br/>
Especifica o modo de preenchimento de gradiente. Para obter uma lista de valores possíveis, consulte [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) no SDK do Windows.

### <a name="return-value"></a>Valor de retorno

VERDADEIRO se bem-sucedido; Caso contrário, FALSE.

### <a name="remarks"></a>Comentários

Para obter mais informações, consulte `GradientFill` no SDK do Windows.

##  <a name="graystring"></a>  CDC::GrayString

Desenha esmaecido texto (cinza) no local especificado por escrever o texto em um bitmap de memória, o bitmap de esmaecimento e, em seguida, copiando o bitmap para a exibição.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*pBrush*<br/>
Identifica o pincel a ser usado para o esmaecimento (tornando cinza).

*lpfnOutput*<br/>
Especifica o endereço da instância do procedimento da função de retorno de chamada fornecida pelo aplicativo que desenhará a cadeia de caracteres. Para obter mais informações, consulte a descrição do que o Windows `OutputFunc` [função de retorno de chamada](callback-functions-used-by-mfc.md#graystring). Se esse parâmetro for NULL, o sistema usa o Windows `TextOut` função para desenhar a cadeia de caracteres, e *lpData* é considerado como um ponteiro longo para a cadeia de caracteres de saída.

*lpData*<br/>
Especifica um ponteiro distante a dados a serem passados para a função de saída. Se *lpfnOutput* for NULL, *lpData* deve ser um ponteiro longo para a cadeia de caracteres de saída.

*nCount*<br/>
Especifica o número de caracteres de saída. Se esse parâmetro for 0, `GrayString` calcula o comprimento da cadeia de caracteres (supondo que *lpData* é um ponteiro para a cadeia de caracteres). Se *nCount* é -1 e a função apontado por *lpfnOutput* retornar 0, a imagem é mostrada, mas não fica esmaecida.

*x*<br/>
Especifica a coordenada x lógica da posição inicial do retângulo que inclui a cadeia de caracteres.

*y*<br/>
Especifica a coordenada y lógica da posição inicial do retângulo que inclui a cadeia de caracteres.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que inclui a cadeia de caracteres. Se *nWidth* é 0, o `GrayString` calcula a largura da área, supondo que *lpData* é um ponteiro para a cadeia de caracteres.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que inclui a cadeia de caracteres. Se *nHeight* é 0, o `GrayString` calcula a altura da área, supondo que *lpData* é um ponteiro para a cadeia de caracteres.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a cadeia de caracteres é desenhada, ou 0 se o `TextOut` função ou a função fornecida pelo aplicativo de saída retornado 0, ou se houver memória suficiente para criar um bitmap de memória para o esmaecimento.

### <a name="remarks"></a>Comentários

A função esmaece o texto, independentemente do pincel selecionado e o plano de fundo. O `GrayString` função membro usa a fonte atualmente selecionada. O modo de mapeamento MM_TEXT deve ser selecionado antes de usar essa função.

Um aplicativo pode desenhar esmaecidas cadeias de caracteres (esmaecidas) em dispositivos que dão suporte a uma cor cinza sólida sem chamar o `GrayString` função de membro. A cor do sistema COLOR_GRAYTEXT é a cor cinza sólido sistema usada para desenhar texto desabilitado. O aplicativo pode chamar o `GetSysColor` função do Windows para recuperar o valor de cor de COLOR_GRAYTEXT. Se a cor é diferente de 0 (preto), o aplicativo pode chamar o `SetTextColor` a função de membro para definir a cor do texto para o valor de cor e, em seguida, desenhar a cadeia de caracteres diretamente. Se a cor recuperada é preta, o aplicativo deve chamar `GrayString` para (cinza)-o texto.

Se *lpfnOutput* for NULL, o Windows usa o GDI [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta) função, e *lpData* é considerado como um ponteiro distante ao caractere a ser gerado. Se os caracteres de saída não podem ser tratados pelos `TextOut` função de membro (por exemplo, a cadeia de caracteres é armazenada como um bitmap), o aplicativo deve fornecer sua própria função de saída.

Além disso, observe que todas as funções de retorno de chamada devem interceptar as exceções do Microsoft Foundation antes de retornar ao Windows, já que as exceções não podem ser geradas entre limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

A função de retorno de chamada passado para `GrayString` deve usar o `__stdcall` convenção de chamada e deve ser exportada com `__declspec`.

Quando o framework estiver no modo de visualização, uma chamada para o `GrayString` função de membro é convertida em um `TextOut` chamada e a função de retorno de chamada não é chamado.

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

Use essa função quando você converter tamanhos HIMETRIC de OLE em pixels.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

Se o modo de mapeamento do objeto de contexto de dispositivo for MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC ou MM_HIMETRIC, a conversão é baseada no número de pixels em polegadas a física. Se o modo de mapeamento é um dos outros modos não limitado (por exemplo, MM_TEXT), a conversão é baseada no número de pixels a polegada lógica.

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

Chame essa função para converter unidades HIMETRIC em unidades lógicas.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura ou [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

Use essa função quando você obter tamanhos HIMETRIC de OLE e deseja convertê-los para o modo de mapeamento natural do seu aplicativo.

A conversão é realizada pelo primeiro converter as unidades HIMETRIC em pixels e, em seguida, converter essas unidades em unidades lógicas usando unidades de mapeamento do contexto de dispositivo atual. Observe que as extensões da janela do dispositivo e o visor afetará o resultado.

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

Cria uma nova região de recorte, formando a interseção da região atual e o retângulo especificado por *x1*, *y1*, *x2*, e *y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo.

*y1*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo.

*x2*<br/>
Especifica a coordenada x lógica do canto inferior direito do retângulo.

*y2*<br/>
Especifica a coordenada y lógica do canto inferior direito do retângulo.

*lpRect*<br/>
Especifica o retângulo. Você pode transmitir uma `CRect` objeto ou um ponteiro para um `RECT` estrutura para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Tipo da nova região de recorte. Ele pode ser qualquer um dos seguintes valores:

- COMPLEXREGION nova região de recorte tem bordas de sobreposição.

- Contexto de dispositivo de erro não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION nova região de recorte tiver sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

GDI Recorta todas as saídas subsequentes para caber dentro dos limites de novo. A largura e altura não devem exceder 32.767.

##  <a name="invertrect"></a>  CDC::InvertRect

Inverte o conteúdo do retângulo especificado.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um `RECT` que contém as coordenadas lógicas do retângulo deve ser invertida. Você também pode passar um `CRect` objeto para esse parâmetro.

### <a name="remarks"></a>Comentários

Inversão é uma lógica não operação e inverte os bits de cada pixel. Em monocromáticas telas, a função faz pixels brancos preto e preto pixels em branco. Em telas de cor, a inversão depende de como as cores são geradas para a exibição. Chamar `InvertRect` duas vezes com o mesmo retângulo restaura a exibição para suas cores anteriores.

Se o retângulo estiver vazio, nada é desenhado.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

Inverte as cores na região especificada por *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região deve ser invertida. As coordenadas para a região são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Em monocromáticas telas, a função faz pixels brancos preto e preto pixels em branco. Em telas de cor, a inversão depende de como as cores são geradas para a exibição.

##  <a name="isprinting"></a>  CDC::IsPrinting

Determina se o contexto de dispositivo está sendo usado para impressão.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o `CDC` objeto é uma impressora DC; caso contrário, 0.

##  <a name="lineto"></a>  CDC::LineTo

Desenha uma linha da posição atual até, mas não incluindo, o ponto especificado por *x* e *y* (ou *aponte*).

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de extremidade para a linha.

*y*<br/>
Especifica a coordenada y lógica do ponto de extremidade para a linha.

*point*<br/>
Especifica o ponto de extremidade para a linha. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a linha é desenhada; Caso contrário, 0.

### <a name="remarks"></a>Comentários

A linha é desenhada com a caneta selecionada. A posição atual está definida como *x*, *y* ou a *aponte*.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="lptodp"></a>  CDC::LPtoDP

Converte as unidades lógicas em unidades de dispositivo.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de pontos. Cada ponto na matriz é um [APONTE](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto.

*nCount*<br/>
O número de pontos da matriz.

*lpRect*<br/>
Aponta para um [RECT](/windows/desktop/api/windef/ns-windef-tagrect) estrutura ou um [CRect](../../atl-mfc-shared/reference/crect-class.md) objeto. Esse parâmetro é usado para o caso comum de mapeamento de um retângulo de coordenadas lógicas para unidades do dispositivo.

*lpSize*<br/>
Aponta para um [tamanho](/windows/desktop/api/windef/ns-windef-tagsize) estrutura ou um [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto.

### <a name="remarks"></a>Comentários

A função mapeia as coordenadas de cada ponto ou dimensões de tamanho, do sistema de coordenadas lógico da GDI em um sistema de coordenadas do dispositivo. A conversão depende do modo de mapeamento atual e as configurações das origens e extensões da janela e o visor do dispositivo.

As coordenadas x e y dos pontos são inteiros com sinal de 2 bytes no intervalo de -32.768 a 32.767. Em casos em que o modo de mapeamento pode resultar em valores maiores do que esses limites, o sistema define os valores de -32.768 e 32.767, respectivamente.

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

Chame essa função para converter unidades lógicas em unidades HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Parâmetros

*lpSize*<br/>
Aponta para um `SIZE` estrutura ou um `CSize` objeto.

### <a name="remarks"></a>Comentários

Use essa função ao conceder tamanhos HIMETRIC a OLE, convertendo do modo de mapeamento natural do seu aplicativo. Observe que as extensões da janela do dispositivo e o visor afetará o resultado.

A conversão é realizada pelo primeiro converter as unidades lógicas em pixels usando unidades de mapeamento do contexto de dispositivo atual e, em seguida, converter essas unidades em unidades HIMETRIC.

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

O contexto de dispositivo para este atributo `CDC` objeto.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Comentários

Por padrão, esse contexto de dispositivo é igual a `m_hDC`. Em geral, `CDC` chamadas GDI que solicitam informações do contexto do dispositivo são direcionadas para `m_hAttribDC`. Consulte a [CDC](../../mfc/reference/cdc-class.md) classe descrição para obter mais informações sobre o uso desses contextos de dispositivo de dois.

##  <a name="m_hdc"></a>  CDC::m_hDC

O contexto de dispositivo de saída para este `CDC` objeto.

```
HDC m_hDC;
```

### <a name="remarks"></a>Comentários

Por padrão, `m_hDC` é igual a `m_hAttribDC`, o contexto de dispositivo que encapsulado por `CDC`. Em geral, `CDC` chamadas GDI que criar saída acessem o `m_hDC` contexto de dispositivo. Você pode inicializar `m_hDC` e `m_hAttribDC` para apontar para diferentes dispositivos. Consulte a [CDC](../../mfc/reference/cdc-class.md) classe descrição para obter mais informações sobre o uso desses contextos de dispositivo de dois.

##  <a name="maskblt"></a>  CDC::MaskBlt

Combina os dados de cor para bitmaps de origem e de destino usando a máscara de determinada e a operação de varredura.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo de destino.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo de destino.

*nWidth*<br/>
Especifica a largura, em unidades lógicas, do bitmap retângulo e a fonte de destino.

*nHeight*<br/>
Especifica a altura, em unidades lógicas, do bitmap retângulo e a fonte de destino.

*pSrcDC*<br/>
Identifica o contexto de dispositivo do qual o bitmap deve ser copiado. Ele deve ser zero se o *dwRop* parâmetro especifica uma operação de varredura que não inclui uma código-fonte.

*xSrc*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do bitmap de origem.

*ySrc*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do bitmap de origem.

*maskBitmap*<br/>
Identifica o bitmap a máscara monocromática combinado com o bitmap colorido no contexto de dispositivo de origem.

*xMask*<br/>
Especifica o deslocamento horizontal do pixel do bitmap de máscara especificado pelo *maskBitmap* parâmetro.

*yMask*<br/>
Especifica o deslocamento vertical de pixel do bitmap de máscara especificado pelo *maskBitmap* parâmetro.

*dwRop*<br/>
Especifica o primeiro e segundo plano códigos de operação de varredura Ternário, que a função usa para controlar a combinação de dados de origem e destino. O código de operação de varredura de plano de fundo é armazenado no byte mais elevado de palavra alta desse valor; o código de operação de varredura de primeiro plano é armazenado no byte baixo da palavra alta desse valor; a palavra inferior desse valor é ignorada e deve ser zero. A macro MAKEROP4 cria essas combinações de primeiro plano e plano de fundo de códigos de operação de varredura. Consulte a seção de comentários para ver uma discussão do primeiro e segundo plano no contexto dessa função. Consulte o `BitBlt` a função de membro para obter uma lista de códigos comuns de operação de varredura.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Um valor de 1 na máscara especificada por *maskBitmap* indica que o código de operação de varredura de primeiro plano especificado por *dwRop* deve ser aplicada nesse local. Um valor de 0 na máscara indica que o código de operação de varredura de plano de fundo especificada por *dwRop* deve ser aplicada nesse local. Se as operações de varredura precisam de uma fonte, o retângulo de máscara deve cobrir o retângulo de origem. Se não existir, a função falhará. Se as operações de varredura não exigem uma fonte, o retângulo de máscara deve cobrir o retângulo de destino. Se não existir, a função falhará.

Se uma transformação de rotação ou distorção estiver em vigor para o contexto de dispositivo de origem quando essa função é chamada, ocorrerá um erro. No entanto, outros tipos de transformações são permitidos.

Se os formatos de cor da fonte, padrão e bitmaps de destino forem diferentes, essa função converte o padrão de formato de origem ou ambos, para corresponder ao formato de destino. Se o bitmap de máscara não é um bitmap monocromático, ocorrerá um erro. Quando um metarquivo avançado está sendo registrado, ocorrerá um erro (e a função retorna 0) se o contexto de dispositivo de origem identifica um contexto de dispositivo de metarquivo avançado. Nem todos os dispositivos oferecem suporte a `MaskBlt`. Um aplicativo deve chamar `GetDeviceCaps` para determinar se um dispositivo dá suporte a essa função. Se o bitmap Nenhuma máscara for fornecida, essa função se comporta exatamente como `BitBlt`, usando o código de operação de varredura de primeiro plano. O pixel deslocamentos no mapa de bitmap de máscara para o ponto (0,0) no bitmap do contexto de dispositivo de origem. Isso é útil para casos em que um bitmap de máscara contém um conjunto de máscaras de; um aplicativo pode facilmente aplicar qualquer um da uma tarefa de máscara blitting ajustando os deslocamentos de pixel e tamanhos de retângulo enviado para `MaskBlt`.

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

Altera a transformação global para um contexto de dispositivo usando o modo especificado.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a um [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) estrutura usada para modificar a transformação global para o contexto de determinado dispositivo.

*iMode*<br/>
Especifica como os dados de transformação modifica a transformação global atual. Para obter uma lista dos valores de que esse parâmetro pode assumir, consulte [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de sucesso.

Retorna 0 em caso de falha.

Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Esse método encapsula a função do Windows GDI [ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform).

##  <a name="moveto"></a>  CDC::MoveTo

Move a posição atual para o ponto especificado por *x* e *y* (ou pelo *aponte*).

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da nova posição.

*y*<br/>
Especifica a coordenada y lógica da nova posição.

*point*<br/>
Especifica a nova posição. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

As coordenadas x e y da posição anterior como um `CPoint` objeto.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

Move a região de recorte do contexto do dispositivo por deslocamentos especificados.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica o número de unidades lógicas para mover para a esquerda ou direita.

*y*<br/>
Especifica o número de unidades lógicas para mover para cima ou para baixo.

*size*<br/>
Especifica a quantidade para deslocar.

### <a name="return-value"></a>Valor de retorno

Tipo da nova região. Ele pode ser qualquer um dos seguintes valores:

- Região de recorte COMPLEXREGION tem bordas de sobreposição.

- Contexto de dispositivo de erro não é válido.

- Região de recorte NULLREGION está vazia.

- Região de recorte SIMPLEREGION tem sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

A função move a região *x* unidades no eixo e *y* unidades no eixo y.

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

Modifica as coordenadas da origem do visor em relação as coordenadas da origem visor atual.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*nWidth*<br/>
Especifica o número de unidades de dispositivo para adicionar a coordenada x da origem atual.

*nHeight*<br/>
Especifica o número de unidades de dispositivo para adicionar a coordenada y da origem atual.

### <a name="return-value"></a>Valor de retorno

A origem do visor anterior (nas coordenadas do dispositivo) como um `CPoint` objeto.

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

Modifica as coordenadas da origem da janela em relação as coordenadas da origem da janela atual.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Parâmetros

*nWidth*<br/>
Especifica o número de unidades lógicas para adicionar a coordenada x da origem atual.

*nHeight*<br/>
Especifica o número de unidades lógicas para adicionar a coordenada y da origem atual.

### <a name="return-value"></a>Valor de retorno

A origem de janela anterior (em coordenadas lógicas) como um `CPoint` objeto.

##  <a name="operator_hdc"></a>  CDC::Operator HDC

Use este operador para recuperar o identificador de contexto de dispositivo do `CDC` objeto.

```
operator HDC() const;
```

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, o identificador do objeto de contexto do dispositivo; Caso contrário, nulo.

### <a name="remarks"></a>Comentários

Você pode usar o identificador para chamar diretamente as APIs do Windows.

##  <a name="paintrgn"></a>  CDC::PaintRgn

Preenche a região especificada por *pRgn* usando o pincel atual.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região a ser preenchido. As coordenadas para a determinada região são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

##  <a name="patblt"></a>  CDC::PatBlt

Cria um padrão de bit no dispositivo.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do canto superior esquerdo do retângulo que receberá o padrão.

*y*<br/>
Especifica a coordenada y lógica do canto superior esquerdo do retângulo que receberá o padrão.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo que receberá o padrão.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo que receberá o padrão.

*dwRop*<br/>
Especifica o código de operação de varredura. Códigos de operação de varredura (ROPs) definem como a GDI combina cores nas operações de saída que envolvem um pincel, um possível bitmap de origem e um bitmap de destino. Esse parâmetro pode ser um dos seguintes valores:

- Padrão de cópias de {1&gt;PATCOPY&lt;1 para o bitmap de destino.

- {1&gt;PATINVERT&lt;1 combina o bitmap de destino com o padrão usando o operador XOR booliano.

- {1&gt;DSTINVERT&lt;1 inverte o bitmap de destino.

- {1&gt;BLACKNESS&lt;1 transforma de que toda a saída preto.

- {1&gt;WHITENESS&lt;1 transforma de que toda a saída em branco.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O padrão é uma combinação de pincel selecionado e o padrão já no dispositivo. O código de operação de varredura especificado por *dwRop* define como os padrões devem ser combinados. As operações de varredura listadas para essa função são um subconjunto limitado dos códigos de operação de varredura Ternário completo 256; em particular, um código de operação de varredura refere-se a uma fonte não pode ser usado.

Nem todos os contextos de dispositivo dão suporte a `PatBlt` função. Para determinar se um contexto de dispositivo dá suporte à `PatBlt`, chame o `GetDeviceCaps` membro de função com o índice RASTERCAPS e verifique o valor retornado para o sinalizador RC_BITBLT.

##  <a name="pie"></a>  CDC::Pie

Desenha uma borda em forma de pizza ao desenhar um arco elíptico cujo centro e dois pontos de extremidade são unidos por linhas.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo delimitador (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo delimitador (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo delimitador (em unidades lógicas).

*x3*<br/>
Especifica a coordenada x do ponto de partida do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y3*<br/>
Especifica a coordenada y do ponto de partida do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*x4*<br/>
Especifica a coordenada x do ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*y4*<br/>
Especifica a coordenada y do ponto de extremidade do arco (em unidades lógicas). Esse ponto não precisa estar exatamente em arco.

*lpRect*<br/>
Especifica o retângulo delimitador. Você pode transmitir uma `CRect` objeto ou um ponteiro para um `RECT` estrutura para esse parâmetro.

*ptStart*<br/>
Especifica o ponto de partida do arco. Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura ou um [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

*ptEnd*<br/>
Especifica o ponto de extremidade do arco. Esse ponto não precisa estar exatamente em arco. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O centro do arco é o centro do retângulo delimitador especificado por *x1*, *y1*, *x2*, e *y2* (ou pelo *lpRect* ). Pontos do arco o início e fim são especificadas por *x3*, *y3*, *x4*, e *y4* (ou pelo *ptStart*e *ptEnd*).

O arco é desenhado com a caneta selecionada, movendo no sentido anti-horário. Duas linhas adicionais são tiradas de cada ponto de extremidade para o centro do arco. A área em forma de pizza é preenchida com o pincel atual. Se *x3* é igual a *x4* e *y3* é igual a *y4*, o resultado é uma elipse com uma única linha do centro da elipse até o ponto ( *x3*, *y3*) ou ( *x4*, *y4*).

A Figura desenhada por essa função se estende até, mas não inclui as coordenadas da direita e inferior. Isso significa que a altura da figura *y2* - *y1* e a largura da figura é *x2* - *x1*. A largura e a altura do retângulo delimitador devem ser maiores que 2 unidades e unidades inferior a 32.767.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

Reproduz o conteúdo do metarquivo especificado no contexto do dispositivo.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Parâmetros

*hMF*<br/>
Identifica o metarquivo a ser reproduzido.

*hEnhMetaFile*<br/>
Identifica o metarquivo avançado.

*lpBounds*<br/>
Aponta para um `RECT` estrutura ou um `CRect` objeto que contém as coordenadas do retângulo delimitador usado para exibir a imagem. As coordenadas são especificadas em unidades lógicas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O metarquivo pode ser executado qualquer número de vezes.

A segunda versão do `PlayMetaFile` exibe a imagem armazenada no metarquivo aprimorado de formato fornecido. Quando um aplicativo chama a segunda versão do `PlayMetaFile`, Windows usa o quadro de imagem no cabeçalho de metarquivo avançado para mapear a imagem para o retângulo apontado pelo *lpBounds* parâmetro. (Essa imagem pode ser distorcida ou girada, definindo a transformação world no dispositivo de saída antes de chamar `PlayMetaFile`.) Pontos ao longo das bordas do retângulo são incluídos na imagem. Uma imagem de metarquivo avançado pode ser recortada definindo-se a região de recorte no dispositivo de saída antes de reproduzir o metarquivo avançado.

Se um metarquivo avançado contiver uma paleta opcional, um aplicativo pode obter cores consistentes, configurando uma paleta de cores no dispositivo de saída antes de chamar a segunda versão do `PlayMetaFile`. Para recuperar a paleta opcional, use o `GetEnhMetaFilePaletteEntries` função do Windows. Um metarquivo avançado pode ser inserido em um metarquivo avançado recentemente criado chamando-se a segunda versão do `PlayMetaFile` e reprodução de metarquivo aprimorado de origem para o contexto de dispositivo para o novo metarquivo avançado.

Os estados de contexto do dispositivo de saída são preservados por essa função. Qualquer objeto criado, mas não excluída no metarquivo aprimorado é excluído por essa função. Para interromper a essa função, um aplicativo pode chamar o `CancelDC` função do Windows de outro thread para concluir a operação. Nesse caso, a função retorna zero.

##  <a name="plgblt"></a>  CDC::PlgBlt

Executa uma transferência de bloco de bits dos bits de dados de cor do retângulo especificado no contexto de dispositivo de origem para o paralelogramo especificado no contexto de determinado dispositivo.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Parâmetros

*lpPoint*<br/>
Aponta para uma matriz de três pontos no espaço lógico que identifica três cantos do paralelogramo de destino. O canto superior esquerdo do retângulo de origem é mapeado para o primeiro ponto no canto inferior esquerdo para o terceiro ponto, o canto superior direito para o segundo ponto nessa matriz e essa matriz. O canto inferior direito do retângulo de origem é mapeado para o ponto de quarto implícito em um paralelogramo.

*pSrcDC*<br/>
Identifica o contexto de dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.

*nWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*maskBitmap*<br/>
Identifica um bitmap monocromático opcional que é usado para mascarar as cores do retângulo de origem.

*xMask*<br/>
Especifica a coordenada x do canto superior esquerdo do bitmap monocromático.

*yMask*<br/>
Especifica a coordenada y do canto superior esquerdo do bitmap monocromático.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Se o identificador de bitmask fornecido identifica um bitmap monocromático válido, a função usa esse bitmap para mascarar os bits de dados de cor do retângulo de origem.

O quarto vértice do paralelogramo (D) é definido, tratando os três primeiros pontos (A, B e C) como vetores e computação D = B + C - A.

Se existir a máscara de bits, um valor de 1 na máscara indica que a cor do pixel de origem deve ser copiada para o destino. Um valor de 0 na máscara indica que a cor de pixel do destino não é devem ser alterados.

Se o retângulo de máscara for menor do que os retângulos de origem e de destino, a função de replica o padrão de máscara.

Transformações de escala, translação e reflexão são permitidas no contexto de dispositivo de origem; No entanto, as transformações de rotação e distorção não são. Se o bitmap de máscara não é um bitmap monocromático, ocorrerá um erro. O modo de alongamento para o contexto de dispositivo de destino é usado para determinar como alongar ou compactar os pixels, se for necessário. Quando um metarquivo avançado está sendo registrado, ocorrerá um erro se o contexto de dispositivo de origem identifica um contexto de dispositivo de metarquivo avançado.

As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem. Se a transformação de origem tem uma rotação ou distorção, um erro será retornado. Se os retângulos de origem e destino não tiverem o mesmo formato de cor, `PlgBlt` converte o retângulo de origem para coincidir com o retângulo de destino. Nem todos os dispositivos oferecem suporte a `PlgBlt`. Para obter mais informações, consulte a descrição do recurso de varredura RC_BITBLT no `CDC::GetDeviceCaps` função de membro.

Se os contextos de dispositivo de origem e de destino representam dispositivos incompatíveis, `PlgBlt` retornará um erro.

##  <a name="polybezier"></a>  CDC::PolyBezier

Desenha uma ou mais splines de Bzier.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas de dados que contêm os pontos de extremidade e pontos do spline(s) controlam.

*nCount*<br/>
Especifica o número de pontos na *lpPoints* matriz. Esse valor deve ser um mais de três vezes o número de splines a ser desenhado, porque cada spline Bzier requer dois pontos de controle e um ponto de extremidade e o spline inicial requer um ponto de partida adicional.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função desenha cúbicas splines de Bzier usando os pontos de extremidade e pontos de controle especificados pela *lpPoints* parâmetro. O spline primeiro é desenhado no primeiro ponto até o quarto ponto usando os pontos do segundo e terceiro como pontos de controle. Cada spline subsequente na sequência precisa exatamente três pontos mais: o ponto de extremidade de spline anterior é usado como o ponto de partida, os dois pontos na sequência estão pontos de controle e o terceiro é o ponto de extremidade.

A posição atual não é usada nem atualizada pelo `PolyBezier` função. A figura não está preenchida. Essa função desenha linhas, usando a caneta atual.

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

Desenha uma ou mais splines de Bzier.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) aponta de estruturas de dados que contém os pontos de extremidade e o controle.

*nCount*<br/>
Especifica o número de pontos na *lpPoints* matriz. Esse valor deve ser três vezes o número de splines a ser desenhado, porque cada spline Bzier requer dois pontos de controle e um ponto de extremidade.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função desenha cúbicas splines de Bzier usando os pontos de controle especificados pela *lpPoints* parâmetro. O primeiro spline é desenhado da posição atual para o terceiro ponto usando os primeiros dois pontos como pontos de controle. Para cada spline subsequente, a função precisa exatamente três mais pontos e usa o ponto de extremidade de spline anterior como o ponto de partida para a próxima. `PolyBezierTo` Move a posição atual para o ponto de extremidade da última Bzier spline. A figura não está preenchida. Essa função desenha linhas, usando a caneta atual.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC:: beginpath](#beginpath).

##  <a name="polydraw"></a>  CDC::PolyDraw

Desenha um conjunto de segmentos de linha e splines Bzier.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas de dados que contém os pontos de extremidade para cada segmento e os pontos de extremidade de linha e pontos para cada spline Bzier de controle.

*lpTypes*<br/>
Aponta para uma matriz que especifica como cada um point-in a *lpPoints* matriz é usada. Valores podem ser um dos seguintes:

- PT_MOVETO Especifica que este ponto inicia uma figura não contíguo. Esse ponto se tornará a nova posição atual.

- PT_LINETO Especifica que uma linha deve ser desenhado da posição atual até o momento, que então se torna a nova posição atual.

- PT_BEZIERTO Especifica que esse ponto é um ponto de controle ou o ponto final para um spline Bzier.

Tipos PT_BEZIERTO sempre ocorrem em conjuntos de três. A posição atual define o ponto de partida para o spline Bzier. Os primeiros dois pontos PT_BEZIERTO são os pontos de controle e o terceiro ponto PT_BEZIERTO é o ponto final. O ponto final se tornará a nova posição atual. Se houver não três pontos PT_BEZIERTO consecutivos, ocorrerá um erro.

   Um tipo PT_LINETO ou PT_BEZIERTO pode ser combinado com a seguinte constante usando o operador bit a bit ou indicar que o ponto correspondente é o último ponto em uma figura e a figura está fechada:

- PT_CLOSEFIGURE Especifica que a figura está fechada automaticamente após o PT_LINETO ou tipo PT_BEZIERTO para este ponto é feito. Uma linha é desenhada desse ponto para o mais recente PT_MOVETO ou `MoveTo` apontar.

   Esse sinalizador é combinado com o tipo PT_LINETO para uma linha ou com o tipo de final para um spline Bzier, usando o bit a bit de PT_BEZIERTO **OR** operador. A posição atual está definida como o ponto final da linha de fechamento.

*nCount*<br/>
Especifica o número total de pontos na *lpPoints* de matriz, igual ao número de bytes na *lpTypes* matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função pode ser usada para desenhar as figuras não contíguas no lugar de chamadas consecutivas para `CDC::MoveTo`, `CDC::LineTo`, e `CDC::PolyBezierTo` funções de membro. As linhas e splines são desenhados usando a caneta atual e figuras não são preenchidas. Se há um caminho ativo iniciado chamando o `CDC::BeginPath` função de membro, `PolyDraw` adiciona ao caminho. Os pontos contidos na *lpPoints* matriz e, na *lpTypes* indicam se cada ponto faz parte de um `CDC::MoveTo`, uma `CDC::LineTo`, ou um `CDC::BezierTo` operação. Também é possível fechar as figuras. Essa função atualiza a posição atual.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC:: beginpath](#beginpath).

##  <a name="polygon"></a>  CDC::Polygon

Desenha um polígono que consiste em dois ou mais pontos (vértices) conectados por linhas, usando a caneta atual.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de pontos que especifica os vértices do polígono. Cada ponto na matriz é um `POINT` estrutura ou um `CPoint` objeto.

*nCount*<br/>
Especifica o número de vértices na matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O sistema fecha o polígono automaticamente, se necessário, desenhando uma linha do último vértice ao primeiro.

O modo de preenchimento de polígono atual pode ser recuperado ou definido usando o `GetPolyFillMode` e `SetPolyFillMode` funções de membro.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

Desenha um conjunto de segmentos de linha que conecta os pontos especificados por *lpPoints*.

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de `POINT` estruturas ou `CPoint` objetos a ser conectado.

*nCount*<br/>
Especifica o número de pontos na matriz. Esse valor deve ser pelo menos 2.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As linhas são desenhadas no primeiro ponto por meio de pontos subsequentes usando a caneta atual. Ao contrário do `LineTo` função de membro, o `Polyline` função não usa nem atualiza a posição atual.

Para obter mais informações, consulte [polilinha](/windows/desktop/api/wingdi/nf-wingdi-polyline) no SDK do Windows.

##  <a name="polylineto"></a>  CDC::PolylineTo

Desenha uma ou mais linhas retas.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estruturas de dados que contém os vértices da linha.

*nCount*<br/>
Especifica o número de pontos na matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Uma linha é desenhada da posição atual até o primeiro ponto especificado pelo *lpPoints* parâmetro usando a caneta atual. Para cada linha adicional, desenha a função do ponto final da linha anterior para o próximo ponto especificado por *lpPoints*. `PolylineTo` Move a posição atual para o ponto final da última linha. Se os segmentos de linha desenhados por essa função formam uma figura fechada, a figura não está preenchida.

##  <a name="polypolygon"></a>  CDC::PolyPolygon

Cria duas ou mais polígonos que são preenchidos usando o modo de preenchimento de polígono atual.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de `POINT` estruturas ou `CPoint` objetos que definem os vértices dos polígonos.

*lpPolyCounts*<br/>
Aponta para uma matriz de inteiros, cada um deles Especifica o número de pontos em um dos polígonos na *lpPoints* matriz.

*nCount*<br/>
O número de entradas na *lpPolyCounts* matriz. Esse número Especifica o número de polígonos a ser desenhado. Esse valor deve ser pelo menos 2.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os polígonos podem ser contíguos ou sobrepostos.

Cada polígono especificado em uma chamada para o `PolyPolygon` função deve ser fechada. Ao contrário de polígonos criados pelo `Polygon` função de membro, os polígonos criados pelo `PolyPolygon` não estão fechados automaticamente.

A função cria duas ou mais polígonos. Para criar um único polígono, um aplicativo deve usar o `Polygon` função de membro.

O modo de preenchimento de polígono atual pode ser recuperado ou definido usando o `GetPolyFillMode` e `SetPolyFillMode` funções de membro.

##  <a name="polypolyline"></a>  CDC::PolyPolyline

Desenha a várias séries de segmentos de linha conectados.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Parâmetros

*lpPoints*<br/>
Aponta para uma matriz de estruturas que contém os vértices das polilinhas. As polilinhas são especificadas consecutivamente.

*lpPolyPoints*<br/>
Aponta para uma matriz de variáveis especificando o número de pontos na *lpPoints* matriz para o polígono correspondente. Cada entrada deve ser maior que ou igual a 2.

*nCount*<br/>
Especifica o número total de contagens de *lpPolyPoints* matriz.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Os segmentos de linha são desenhados usando a caneta atual. As figuras formadas pelos segmentos não são preenchidas. A posição atual não é usada nem atualizada por essa função.

##  <a name="ptvisible"></a>  CDC::PtVisible

Determina se o determinado ponto está dentro da região de recorte do contexto do dispositivo.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto.

*y*<br/>
Especifica a coordenada y lógica do ponto.

*point*<br/>
Especifica o ponto de verificação em coordenadas lógicas. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o ponto especificado está dentro da região de recorte; Caso contrário, 0.

##  <a name="queryabort"></a>  CDC::QueryAbort

Chama a função abort instalada pela [SetAbortProc](#setabortproc) função de membro para um aplicativo de impressão e consultas, se a impressão deve ser encerrada.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Valor de retorno

O valor de retorno é diferente de zero se a impressão deve continuar ou se não houver nenhum procedimento de anulação. É 0 se o trabalho de impressão deve ser encerrado. O valor retornado é fornecido pela função de anulação.

##  <a name="realizepalette"></a>  CDC::RealizePalette

Mapeia as entradas da paleta lógica atual para a paleta do sistema.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Valor de retorno

Indica o número de entradas da paleta lógica foram mapeado para as entradas diferentes na paleta do sistema. Isso representa o número de entradas que essa função é remapeada para acomodar as alterações na paleta do sistema, pois a paleta lógica foi realizada pela última vez.

### <a name="remarks"></a>Comentários

Uma paleta de cores lógicas atua como um buffer entre aplicativos com uso intensivo de cor e o sistema, permitindo que um aplicativo para usar como muitas cores conforme necessário sem interferir com seu próprio exibido cores ou com cores exibidas por outras janelas.

Quando uma janela tem o foco de entrada e chama `RealizePalette`, Windows garante que a janela exibirá todas as cores solicitadas, até o número máximo disponível na tela simultaneamente. Windows também exibe as cores não encontradas na paleta da janela, comparando-as às cores disponíveis.

Além disso, o Windows corresponde as cores solicitadas pelo windows inativos que chamam a função mais próximo possível para as cores disponíveis. Isso reduz significativamente a alterações indesejadas nas cores exibidas nas janelas inativas.

##  <a name="rectangle"></a>  CDC::Rectangle

Desenha um retângulo usando a caneta atual.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo em unidades lógicas. Você pode transmitir uma `CRect` objeto ou um ponteiro para um `RECT` estrutura para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

O retângulo se estende até, mas não inclui as coordenadas da direita e inferior. Isso significa que a altura do retângulo *y2* - *y1* e a largura do retângulo é *x2* - *x1*. A largura e a altura de um retângulo devem ser maiores que 2 unidades e unidades inferior a 32.767.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

Determina se qualquer parte do retângulo especificado está dentro da região de recorte do contexto de exibição.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Parâmetros

*lpRect*<br/>
Aponta para um `RECT` estrutura ou um `CRect` objeto que contém as coordenadas lógicas do retângulo especificado.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se qualquer parte do retângulo especificado está dentro da região de recorte; Caso contrário, 0.

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

Chame essa função de membro para definir `m_hAttribDC` como NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Comentários

Isso não causa um `Detach` ocorra. Somente o contexto de dispositivo de saída está anexado a `CDC` objeto e somente ele podem ser desanexado.

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

Chame essa função de membro para definir o `m_hDC` membro como NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Comentários

Essa função de membro não pode ser chamada quando o contexto de dispositivo de saída é anexado ao `CDC` objeto. Use o `Detach` a função de membro para desanexar o contexto de dispositivo de saída.

##  <a name="resetdc"></a>  CDC::ResetDC

Chame essa função de membro para atualizar o contexto de dispositivo encapsulado pelo `CDC` objeto.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Parâmetros

*lpDevMode*<br/>
Um ponteiro para um Windows `DEVMODE` estrutura.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto de dispositivo é atualizado das informações especificadas no Windows `DEVMODE` estrutura. Essa função de membro só redefine o contexto de dispositivo do atributo.

Um aplicativo normalmente usará o `ResetDC` função de membro quando uma janela processa um `WM_DEVMODECHANGE` mensagem. Você também pode usar essa função de membro para alterar a orientação do papel ou compartimentos de papel ao imprimir um documento.

Você não pode usar essa função de membro para alterar o nome do driver, o nome do dispositivo ou a porta de saída. Quando o usuário altera a conexão de porta ou nome do dispositivo, você deve excluir o contexto de dispositivo original e criar um novo contexto de dispositivo com as novas informações.

Antes de chamar essa função membro, você deve garantir que todos os objetos que tiverem sido selecionados no contexto de dispositivo (diferente de objetos de estoque) foram selecionados-out.

##  <a name="restoredc"></a>  CDC::RestoreDC

Restaura o contexto de dispositivo para o estado anterior identificado pelo *nSavedDC*.

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Parâmetros

*nSavedDC*<br/>
Especifica o contexto de dispositivo a ser restaurado. Ele pode ser um valor retornado por uma anterior `SaveDC` chamada de função. Se *nSavedDC* é -1, salvo mais recentemente o contexto de dispositivo é restaurado.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o contexto especificado tiver sido restaurado; Caso contrário, 0.

### <a name="remarks"></a>Comentários

`RestoreDC` Restaura o contexto de dispositivo, exibindo informações de estado de uma pilha criados por chamadas anteriores para o `SaveDC` função de membro.

A pilha pode conter as informações de estado para vários contextos de dispositivo. Se o contexto especificado pelo *nSavedDC* não está no topo da pilha, `RestoreDC` exclui todas as informações de estado entre o contexto de dispositivo especificado por *nSavedDC* e a parte superior da pilha. As informações excluídas serão perdidas.

##  <a name="roundrect"></a>  CDC::RoundRect

Desenha um retângulo com cantos arredondados, usando a caneta atual.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Parâmetros

*x1*<br/>
Especifica a coordenada x do canto superior esquerdo do retângulo (em unidades lógicas).

*y1*<br/>
Especifica a coordenada y do canto superior esquerdo do retângulo (em unidades lógicas).

*x2*<br/>
Especifica a coordenada x do canto inferior direito do retângulo (em unidades lógicas).

*y2*<br/>
Especifica a coordenada y do canto inferior direito do retângulo (em unidades lógicas).

*x3*<br/>
Especifica a largura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*y3*<br/>
Especifica a altura da elipse usada para desenhar os cantos arredondados (em unidades lógicas).

*lpRect*<br/>
Especifica o retângulo delimitador em unidades lógicas. Você pode transmitir uma `CRect` objeto ou um ponteiro para um `RECT` estrutura para esse parâmetro.

*point*<br/>
A coordenada x do *aponte* Especifica a largura da elipse para desenhar os cantos arredondados (em unidades lógicas). A coordenada y do *aponte* Especifica a altura da elipse para desenhar os cantos arredondados (em unidades lógicas). Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O interior do retângulo é preenchido usando o pincel atual.

A figura a que essa função desenha estende até, mas não inclui as coordenadas da direita e inferior. Isso significa que a altura da figura *y2* - *y1* e a largura da figura é *x2* - *x1*. A altura e a largura do retângulo delimitador devem ser maiores que 2 unidades e unidades inferior a 32.767.

### <a name="example"></a>Exemplo

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

Salva o estado atual do contexto do dispositivo, copiando informações de estado (como a região de recorte, objetos selecionados e modo de mapeamento) para uma pilha de contexto mantida pelo Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Valor de retorno

Um inteiro que identifica o contexto de dispositivo salva. Ele é 0, se ocorrer um erro. Isso retornará o valor pode ser usado para restaurar o contexto de dispositivo chamando `RestoreDC`.

### <a name="remarks"></a>Comentários

O contexto de dispositivo salvo mais tarde pode ser restaurado usando `RestoreDC`.

`SaveDC` pode ser usado qualquer número de vezes para salvar qualquer número de estados de contexto de dispositivo.

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

Modifica as extensões do visor em relação aos valores atuais.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a x-extensão atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação x-extensão atual pelo valor de *xNum* parâmetro.

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão de y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação na extensão de y atual pelo valor de *yNum* parâmetro.

### <a name="return-value"></a>Valor de retorno

As extensões de visor anterior (em unidades de dispositivo) como um `CSize` objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte maneira:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

As novas extensões do visor são calculadas multiplicando-se as extensões atuais pelo numerador determinado e, em seguida, dividindo pelo denominador determinado.

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

Modifica as extensões de janela em relação aos valores atuais.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Parâmetros

*xNum*<br/>
Especifica a quantidade pela qual multiplicar a x-extensão atual.

*xDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação x-extensão atual pelo valor de *xNum* parâmetro.

*yNum*<br/>
Especifica a quantidade pela qual multiplicar a extensão de y atual.

*yDenom*<br/>
Especifica a quantidade pela qual dividir o resultado da multiplicação na extensão de y atual pelo valor de *yNum* parâmetro.

### <a name="return-value"></a>Valor de retorno

As extensões de janela anterior (em unidades lógicas) como um `CSize` objeto.

### <a name="remarks"></a>Comentários

As fórmulas são escritas da seguinte maneira:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

As novas extensões de janela são calculadas multiplicando-se as extensões atuais pelo numerador determinado e, em seguida, dividindo pelo denominador determinado.

##  <a name="scrolldc"></a>  CDC::ScrollDC

Rola um retângulo de bits horizontalmente e verticalmente.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Parâmetros

*dx*<br/>
Especifica o número de unidades de rolagem horizontal.

*dy*<br/>
Especifica o número de unidades de rolagem vertical.

*lpRectScroll*<br/>
Aponta para o `RECT` estrutura ou `CRect` objeto que contém as coordenadas do retângulo de rolagem.

*lpRectClip*<br/>
Aponta para o `RECT` estrutura ou `CRect` objeto que contém as coordenadas do retângulo de recorte. Quando esse retângulo é menor do que o original um apontada por *lpRectScroll*, rolagem ocorre apenas no retângulo menor.

*pRgnUpdate*<br/>
Identifica a região revelada pelo processo de rolagem. O `ScrollDC` função define essa região; ele não é necessariamente um retângulo.

*lpRectUpdate*<br/>
Aponta para o `RECT` estrutura ou `CRect` objeto que recebe as coordenadas do retângulo que delimita a área de rolagem de atualização. Isso é a maior área retangular que exige o redesenho. A estrutura ou o objeto quando a função retorna os valores estão em coordenadas do cliente, independentemente do modo de mapeamento para o contexto de determinado dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a rolagem é executada; Caso contrário, 0.

### <a name="remarks"></a>Comentários

Se *lpRectUpdate* é NULL, o Windows não computa o retângulo de atualização. Se os dois *pRgnUpdate* e *lpRectUpdate* forem NULL, o Windows não computa a região de atualização. Se *pRgnUpdate* não for nulo, Windows pressupõe que ele contém um ponteiro válido para a região revelado pelo processo de rolagem (definido pelo `ScrollDC` função de membro). Região de atualização retornada em *lpRectUpdate* pode ser passado para `CWnd::InvalidateRgn` se necessário.

Um aplicativo deve usar o `ScrollWindow` função de membro da classe `CWnd` quando é necessário rolar toda a área cliente de uma janela. Caso contrário, ele deve usar `ScrollDC`.

##  <a name="selectclippath"></a>  CDC::SelectClipPath

Seleciona o caminho atual como uma região de recorte para o contexto de dispositivo, combinando a nova região com qualquer região de recorte existente usando o modo especificado.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Parâmetros

*nMode*<br/>
Especifica a maneira de usar o caminho. Os valores a seguir são permitidos:

- A nova região de recorte de RGN_AND inclui a interseção da região de recorte atual e o caminho atual (áreas de sobreposição).

- RGN_COPY a nova região de recorte é o caminho atual.

- A nova região de recorte de RGN_DIFF inclui as áreas da região de recorte atual e aqueles do caminho atual serão excluídas.

- A nova região de recorte de RGN_OR inclui a união (áreas combinadas) da região de recorte atual e o caminho atual.

- A nova região de recorte de RGN_XOR inclui a união da região de recorte atual e o caminho atual, mas sem as áreas sobrepostas.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto de dispositivo identificado deve conter um caminho fechado.

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

Seleciona a determinada região como a região de recorte atual para o contexto de dispositivo.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Parâmetros

*pRgn*<br/>
Identifica a região a ser selecionado.

- Para a primeira versão dessa função, se esse valor for NULL, toda a área cliente é selecionada e saída ainda é recortada para a janela.

- Para a segunda versão dessa função, esse identificador pode ser NULL somente quando o modo RGN_COPY é especificado.

*nMode*<br/>
Especifica a operação a ser executada. Ele deve ser um dos seguintes valores:

- RGN_AND a nova região de recorte combina as áreas sobrepostas da região de recorte atual e a região identificado pelo *pRgn*.

- RGN_COPY a nova região de recorte é uma cópia da região identificado pelo *pRgn*. Essa é uma funcionalidade é idêntica à primeira versão do `SelectClipRgn`. Se a região é identificado por *pRgn* for NULL, a nova região de recorte torna-se a região de recorte de padrão (uma região nula).

- RGN_DIFF a nova região de recorte combina as áreas da região de recorte atual com essas áreas excluídas da região identificado pelo *pRgn*.

- RGN_OR a nova região de recorte combina a região de recorte atual e a região identificado pelo *pRgn*.

- RGN_XOR a nova região de recorte combina a região de recorte atual e a região identificado pelo *pRgn* mas exclui as áreas sobrepostas.

### <a name="return-value"></a>Valor de retorno

Tipo da região. Ele pode ser qualquer um dos seguintes valores:

- COMPLEXREGION nova região de recorte tem bordas de sobreposição.

- Contexto de dispositivo de erro ou a região não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION nova região de recorte tiver sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

Apenas uma cópia da região selecionada é usada. A região em si pode ser selecionada para qualquer número de outros contextos de dispositivo ou ele pode ser excluído.

A função pressupõe que as coordenadas para a determinada região são especificadas em unidades de dispositivo. Alguns dispositivos de impressora dão suporte a saída de texto em uma resolução mais alta que a saída de gráficos para manter a precisão necessária para expressar as métricas de texto. Esses dispositivos relatam unidades de dispositivo com a resolução mais alta, ou seja, em unidades de texto. Esses dispositivos, em seguida, dimensionar as coordenadas para gráficos, de modo que várias reportadas mapa de unidades de dispositivo a apenas 1 unidade de gráfico. Você sempre deve chamar o `SelectClipRgn` funcionam usando unidades de texto.

Aplicativos que devem levar o dimensionamento de objetos gráficos no GDI podem usar o escape de impressora GETSCALINGFACTOR para determinar o fator de escala. O fator de dimensionamento afeta o recorte. Se uma região é usada para recortar elementos gráficos, GDI divide as coordenadas pelo fator de dimensionamento. Se a região é usada para recortar texto, GDI não torna nenhum ajuste de escala. Um fator de escala de 1 faz com que as coordenadas a ser dividido por 2; um fator de escala de 2 faz com que as coordenadas a ser dividida por 4; e assim por diante.

##  <a name="selectobject"></a>  CDC::SelectObject

Seleciona um objeto no contexto de dispositivo.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Parâmetros

*pPen*<br/>
Um ponteiro para um [CPen](../../mfc/reference/cpen-class.md) objeto a ser selecionado.

*pBrush*<br/>
Um ponteiro para um [CBrush](../../mfc/reference/cbrush-class.md) objeto a ser selecionado.

*pFont*<br/>
Um ponteiro para um [CFont](../../mfc/reference/cfont-class.md) objeto a ser selecionado.

*pBitmap*<br/>
Um ponteiro para um [CBitmap](../../mfc/reference/cbitmap-class.md) objeto a ser selecionado.

*pRgn*<br/>
Um ponteiro para um [CRgn](../../mfc/reference/crgn-class.md) objeto a ser selecionado.

*pObject*<br/>
Um ponteiro para um [CGdiObject](../../mfc/reference/cgdiobject-class.md) objeto a ser selecionado.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para o objeto que está sendo substituído. Esse é um ponteiro para um objeto de uma das classes derivadas de `CGdiObject`, tais como `CPen`, dependendo de qual versão da função é usada. O valor retornado é NULL se não houver um erro. Esta função pode retornar um ponteiro para um objeto temporário. Esse objeto temporário só é válido durante o processamento de uma mensagem do Windows. Para obter mais informações, consulte `CGdiObject::FromHandle`.

A versão da função de membro que aceita um parâmetro de região executa a mesma tarefa que o `SelectClipRgn` função de membro. Seu valor de retorno pode ser qualquer um dos seguintes:

- COMPLEXREGION nova região de recorte tem bordas de sobreposição.

- Contexto de dispositivo de erro ou a região não é válido.

- NULLREGION nova região de recorte está vazia.

- SIMPLEREGION nova região de recorte tiver sem bordas sobrepostas.

### <a name="remarks"></a>Comentários

Classe `CDC` fornece cinco versões especializadas para tipos específicos de objetos GDI, incluindo pincéis, canetas, fontes, bitmaps e regiões. O objeto recém-selecionado substitui o objeto anterior do mesmo tipo. Por exemplo, se *pObject* da versão geral da `SelectObject` aponta para um [CPen](../../mfc/reference/cpen-class.md) do objeto, a função substitui a caneta atual com a caneta especificada por *pObject* .

Um aplicativo pode selecionar um bitmap em contextos de dispositivo de memória somente e no contexto de dispositivo de memória de apenas um por vez. O formato do bitmap deve ser monocromático ou compatível com o contexto de dispositivo; Se não estiver, `SelectObject` retornará um erro.

Para o Windows 3.1 e posterior, o `SelectObject` função retorna o mesmo valor se ele é usado em um metarquivo ou não. Em versões anteriores do Windows, `SelectObject` retornou um valor diferente de zero para êxito e 0 para falha quando ela foi usada em um metarquivo.

##  <a name="selectpalette"></a>  CDC::SelectPalette

Seleciona a paleta lógica que é especificada pelo *pPalette* como o objeto selecionado paleta do contexto do dispositivo.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Parâmetros

*pPalette*<br/>
Identifica a paleta lógica a ser selecionado. Essa paleta já deve ter sido criada com o `CPalette` função de membro [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette).

*bForceBackground*<br/>
Especifica se a paleta lógica é forçada a ser uma paleta de plano de fundo. Se *bForceBackground* é diferente de zero, a paleta selecionada é sempre uma paleta em segundo plano, independentemente se a janela tiver o foco de entrada. Se *bForceBackground* é 0 e o contexto de dispositivo é anexado a uma janela, a paleta lógica é uma paleta de primeiro plano quando a janela tem o foco de entrada.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para um `CPalette` objeto identificando a paleta lógica substituída pela paleta especificada pela *pPalette*. É NULL se não houver um erro.

### <a name="remarks"></a>Comentários

A nova paleta torna-se o objeto de paleta usado por GDI para cores de controle exibidas no contexto de dispositivo e substitui a paleta anterior.

Um aplicativo pode selecionar uma paleta lógica em mais de um contexto de dispositivo. No entanto, as alterações uma paleta lógica afetarão todos os contextos de dispositivo para o qual ele está selecionado. Se um aplicativo seleciona uma paleta em mais de um contexto de dispositivo, os contextos de dispositivo devem pertencer ao mesmo dispositivo físico.

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

Seleciona uma [CGdiObject](../../mfc/reference/cgdiobject-class.md) objeto que corresponde a um do pincéis, canetas de ações predefinidas ou fontes.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Parâmetros

*nIndex*<br/>
Especifica o tipo de objeto de estoque desejado. Ele pode ser um dos seguintes valores:

- Pincel preto BLACK_BRUSH.

- Pincel cinza DKGRAY_BRUSH escuro.

- Pincel GRAY_BRUSH cinza.

- Pincel HOLLOW_BRUSH vazado.

- Pincel de luz de LTGRAY_BRUSH cinza.

- Pincel NULL_BRUSH nulo.

- Pincel WHITE_BRUSH branco.

- Caneta BLACK_PEN preto.

- Caneta NULL_PEN nulo.

- Caneta WHITE_PEN branco.

- ANSI ANSI_FIXED_FONT correção de fonte do sistema.

- Fonte de variável de sistema ANSI_VAR_FONT ANSI.

- Fonte do DEVICE_DEFAULT_FONT dependente de dispositivo.

- Dependente de OEM OEM_FIXED_FONT corrigido da fonte.

- SYSTEM_FONT a fonte do sistema. Por padrão, o Windows usa a fonte do sistema para desenhar menus, controles de caixa de diálogo e outros textos. No entanto, é melhor, não a depender de SYSTEM_FONT para obter a fonte usada pelas caixas de diálogo e janelas. Em vez disso, use o `SystemParametersInfo` função com o parâmetro SPI_GETNONCLIENTMETRICS para recuperar a fonte atual. `SystemParametersInfo` leva em consideração o tema atual e fornece informações de fonte para as legendas, menus e caixas de diálogo de mensagem.

- SYSTEM_FIXED_FONT a fonte de sistema de largura fixa usada no Windows antes da versão 3.0. Esse objeto está disponível para compatibilidade com versões anteriores do Windows.

- Paleta de cores DEFAULT_PALETTE padrão. Essa paleta consiste das 20 estáticas cores na paleta do sistema.

### <a name="return-value"></a>Valor de retorno

Um ponteiro para o `CGdiObject` objeto que foi substituído se a função for bem-sucedida. O objeto real apontado é um [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), ou [CFont](../../mfc/reference/cfont-class.md) objeto. Se a chamada for bem-sucedida, o valor retornado é NULL.

##  <a name="setabortproc"></a>  CDC::SetAbortProc

Instala o procedimento de anular para o trabalho de impressão.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Parâmetros

*lpfn*<br/>
Um ponteiro para a função abort para instalar como o procedimento de anulação. Para obter mais informações sobre a função de retorno de chamada, consulte [função de retorno de chamada para CDC:: SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Valor de retorno

Especifica o resultado do `SetAbortProc` função. Alguns dos valores a seguir são mais prováveis que outros, mas todas são possíveis.

- Erro geral de SP_ERROR.

- Não SP_OUTOFDISK espaço em disco suficiente está disponível atualmente para o spool e não há mais espaço se tornará disponível.

- SP_OUTOFMEMORY não há memória suficiente está disponível para o spool.

- Usuário SP_USERABORT terminou o trabalho por meio do Gerenciador de impressão.

### <a name="remarks"></a>Comentários

Se um aplicativo é permitir que o trabalho de impressão seja cancelado durante spool, ele deve definir a função abort antes do trabalho de impressão é iniciado com o [StartDoc](#startdoc) função de membro. O Gerenciador de impressão chama a função de anulação durante spool para permitir que o aplicativo para cancelar o trabalho de impressão ou para processar as condições de insuficiência de espaço em disco. Se nenhuma função de anulação for definida, o trabalho de impressão falhará se não houver espaço em disco suficiente para o spool.

Observe que os recursos do Microsoft Visual C++ simplificam a criação da função de retorno de chamada passada para `SetAbortProc`. O endereço passado para o `EnumObjects` função de membro é um ponteiro para uma função exportada com `__declspec(dllexport)` e com o `__stdcall` convenção de chamada.

Também não é necessário exportar o nome da função em uma **exportações** instrução no arquivo de definição de módulo do seu aplicativo. Em vez disso, você pode usar o **exportar** função modificador, como em

**EXPORTAÇÃO de retorno de chamada de BOOL** AFunction ( **HDC**, `int` **);**

Para fazer com que o compilador emita o registro de exportação apropriadas para exportação por nome sem alias. Isso funciona para a maioria das necessidades. Para alguns casos especiais, como exportar uma função por ordinal ou alias a exportação, você ainda precisa usar um **exportações** instrução em um arquivo de definição de módulo.

Interfaces de registro de retorno de chamada agora são fortemente tipadas (você deve passar um ponteiro de função que aponta para o tipo correto de função para o retorno de chamada específico).

Além disso, observe que todas as funções de retorno de chamada devem interceptar as exceções do Microsoft Foundation antes de retornar ao Windows, já que as exceções não podem ser geradas entre limites de retorno de chamada. Para obter mais informações sobre exceções, consulte o artigo [exceções](../../mfc/exception-handling-in-mfc.md).

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

Define a direção de desenho a ser usado para funções de arco e retângulo.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Parâmetros

*nArcDirection*<br/>
Especifica a nova direção do arco. Esse parâmetro pode ser qualquer um dos seguintes valores:

- Figuras de AD_COUNTERCLOCKWISE desenhados no sentido anti-horário.

- Figuras de AD_CLOCKWISE desenhados no sentido horário.

### <a name="return-value"></a>Valor de retorno

Especifica a direção do arco antiga, se for bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

A direção padrão é no sentido anti-horário. O `SetArcDirection` função especifica a direção na qual as funções a seguir desenho:

|Arc|Pizza|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

Chame essa função para definir o contexto de dispositivo de atributo, `m_hAttribDC`.

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="remarks"></a>Comentários

Essa função de membro não anexa o contexto de dispositivo para o `CDC` objeto. Somente o contexto de dispositivo de saída é anexado a um `CDC` objeto.

##  <a name="setbkcolor"></a>  CDC::SetBkColor

Define a cor de plano de fundo atual com a cor especificada.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor de plano de fundo.

### <a name="return-value"></a>Valor de retorno

A cor de plano de fundo anterior como um valor de cor RGB. Se ocorrer um erro, o valor de retorno é 0x80000000.

### <a name="remarks"></a>Comentários

Se o modo de tela de fundo é OPACO, o sistema usa a cor do plano de fundo para preencher as lacunas em linhas com estilo definido, as lacunas entre linhas tracejadas em pincéis e o plano de fundo em células de caractere. O sistema também usa a cor do plano de fundo quando convertendo bitmaps entre cores e contextos de dispositivo monocromático.

Se o dispositivo não é possível exibir a cor especificada, o sistema define a cor do plano de fundo para a cor mais próxima de física.

##  <a name="setbkmode"></a>  CDC::SetBkMode

Define o modo de tela de fundo.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Parâmetros

*nBkMode*<br/>
Especifica o modo a ser definido. Esse parâmetro pode ser qualquer um dos seguintes valores:

- Plano de fundo OPACO é preenchido com a cor de plano de fundo atual antes do texto, o pincel tracejada, ou caneta é desenhada. Este é o modo de tela de fundo do padrão.

- Plano de fundo TRANSPARENTE não é alterado antes do desenho.

### <a name="return-value"></a>Valor de retorno

O modo de tela de fundo anterior.

### <a name="remarks"></a>Comentários

O modo de tela de fundo define se o sistema remove as cores de plano de fundo existentes na superfície de desenho antes do desenho de texto, pincéis tracejadas ou qualquer estilo de caneta que não é uma linha sólida.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

Controla o acúmulo de informações do retângulo delimitador para o contexto de dispositivo especificado.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Parâmetros

*lpRectBounds*<br/>
Aponta para um `RECT` estrutura ou `CRect` objeto que é usado para definir o retângulo delimitador. As dimensões do retângulo são dadas em coordenadas lógicas. Esse parâmetro pode ser NULL.

*flags*<br/>
Especifica como o novo retângulo será combinado com o retângulo da acumulados. Esse parâmetro pode ser uma combinação dos seguintes valores:

- DCB_ACCUMULATE, adicione o retângulo especificado por *lpRectBounds* ao retângulo delimitador (usando uma operação de união do retângulo).

- DCB_DISABLE desativar acúmulo dos limites.

- DCB_ENABLE ativar o acúmulo de limites. (A configuração padrão para o acúmulo de limites é desabilitada.)

### <a name="return-value"></a>Valor de retorno

O estado atual do retângulo delimitador, se a função for bem-sucedida. Como o *sinalizadores*, o valor retornado pode ser uma combinação de **DCB_** valores:

- O retângulo delimitador de DCB_ACCUMULATE não está vazio. Esse valor sempre será definido.

- Acúmulo de limites DCB_DISABLE está desativado.

- Acúmulo de limites DCB_ENABLE está.

### <a name="remarks"></a>Comentários

Windows podem manter um retângulo delimitador para todas as operações de desenho. Esse retângulo pode ser consultado e redefinir pelo aplicativo. Os limites do desenho são úteis para invalidar os caches de bitmap.

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

Especifica a origem que GDI atribuirá ao Pincel próximo que o aplicativo seleciona no contexto de dispositivo.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da nova origem. Esse valor deve estar no intervalo de 0 a 7.

*y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da nova origem. Esse valor deve estar no intervalo de 0 a 7.

*point*<br/>
Especifica as coordenadas x e y da nova origem. Cada valor deve estar no intervalo de 0 a 7. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior do pincel em unidades de dispositivo.

### <a name="remarks"></a>Comentários

O padrão de coordenadas para a origem do pincel são (0, 0). Para alterar a origem de um pincel, chame o `UnrealizeObject` funcionar para o `CBrush` do objeto, chame `SetBrushOrg`e, em seguida, chame o `SelectObject` a função de membro para selecionar o pincel para o contexto de dispositivo.

Não use `SetBrushOrg` com o estoque `CBrush` objetos.

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

Define os valores de ajuste de cor para o contexto de dispositivo usando os valores especificados.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Parâmetros

*lpColorAdjust*<br/>
Aponta para um [COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment) estrutura de dados que contém os valores de ajuste de cor.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

Os valores de ajuste de cor são usados para ajustar a cor de entrada do bitmap de origem para chamadas para o `CDC::StretchBlt` função de membro, quando o modo de meio-tom é definido.

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

Define a cor atual do pincel de DC (contexto) do dispositivo para o valor de cor especificada.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor do pincel.

### <a name="return-value"></a>Valor de retorno

Se a função for bem-sucedida, o valor de retorno Especifica a cor do pincel DC anterior como um valor COLORREF.

Se a função falhar, o valor de retorno é CLR_INVALID.

### <a name="remarks"></a>Comentários

Esse método emula a funcionalidade da função [SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor), conforme descrito no SDK do Windows.

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

Define a cor da caneta atual dispositivo DC (contexto) para o valor de cor especificada.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a nova cor da caneta.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função membro utiliza a função Win32 [SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor), conforme descrito no SDK do Windows.

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

Define o modo de gráfico para o contexto de dispositivo especificado.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Parâmetros

*iMode*<br/>
Especifica o modo de gráfico. Para obter uma lista dos valores de que esse parâmetro pode assumir, consulte [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

### <a name="return-value"></a>Valor de retorno

Retorna o modo de gráfico antigos em caso de sucesso.

Retorna 0 em caso de falha. Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Esse método encapsula a função do Windows GDI [SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode).

##  <a name="setlayout"></a>  CDC::SetLayout

Chame essa função de membro para alterar o layout do texto e elementos gráficos para um contexto de dispositivo para a direita para esquerda, o layout padrão para culturas, como árabe e hebraico.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Parâmetros

*dwLayout*<br/>
Sinalizadores de controle de layout de contexto de dispositivo e bitmap. Ele pode ser uma combinação dos valores a seguir.

|Valor|Significado|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Desabilita qualquer reflexão para chamadas para [CDC::BitBlt](#bitblt) e [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Define o layout horizontal de padrão para a direita para a esquerda.|
|LAYOUT_LTR|Define o layout padrão a ser deixado para a direita.|

### <a name="return-value"></a>Valor de retorno

Se for bem-sucedido, o layout anterior do contexto do dispositivo.

Se não for bem-sucedido, GDI_ERROR. Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Normalmente, você não poderia chamar `SetLayout` para uma janela. Em vez disso, você controla o layout da direita para a esquerda em uma janela, definindo o [estilos de janela estendidos](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) como WS_EX_RTLREADING. Um contexto de dispositivo, como uma impressora ou um metarquivo não herdará esse layout. A única maneira de definir o contexto de dispositivo para um layout da direita para esquerda é chamando `SetLayout`.

Se você chamar **SetLayout (LAYOUT_RTL** ), `SetLayout` automaticamente altera o modo de mapeamento para MM_ISOTROPIC. Como resultado, uma chamada subsequente para [GetMapMode](#getmapmode) retornará MM_ISOTROPIC em vez de MM_TEXT.

Em alguns casos, como com muitos bitmaps, você talvez queira preservar o layout da esquerda para a direita. Nesses casos, renderizar a imagem chamando `BitBlt` ou `StretchBlt`, em seguida, defina o sinalizador de controle de bitmap para *dwLayout* para LAYOUT_BITMAPORIENTATIONPRESERVED.

Depois que você alterar o layout com o sinalizador LAYOUT_RTL, os sinalizadores que especificam normalmente direita ou esquerda é revertida. Para evitar confusão, você talvez queira definir nomes alternativos para os sinalizadores padrão. Para obter uma lista de nomes de sinalizador alternativas sugeridas, consulte [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) no SDK do Windows.

##  <a name="setmapmode"></a>  CDC::SetMapMode

Define o modo de mapeamento.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Parâmetros

*nMapMode*<br/>
Especifica o novo modo de mapeamento. Ele pode ser qualquer um dos seguintes valores:

- Unidades lógicas MM_ANISOTROPIC são convertidos em unidades arbitrárias com eixos com escala arbitrariamente. Definir o modo de mapeamento para MM_ANISOTROPIC não altera as configurações de janela ou o visor atuais. Para alterar as unidades, orientação e dimensionamento, chamam o [SetWindowExt](#setwindowext) e [SetViewportExt](#setviewportext) funções de membro.

- MM_HIENGLISH cada unidade lógica é convertido em 0,001 pol. X positivo é para a direita; y positivo está ativo.

- MM_HIMETRIC cada unidade lógica é convertido em corresponde a 0,01 milímetro. X positivo é para a direita; y positivo está ativo.

- Unidades lógicas MM_ISOTROPIC são convertidas para unidades arbitrárias com igualmente eixos com escala; ou seja, 1 unidade ao longo do eixo x é igual a 1 unidade ao longo do eixo y. Use o `SetWindowExt` e `SetViewportExt` funções de membro para especificar as unidades desejadas e a orientação dos eixos. GDI faz ajustes conforme necessário para garantir que o x e y unidades permanecerem o mesmo tamanho.

- MM_LOENGLISH cada unidade lógica é convertido em 0,01 polegada. X positivo é para a direita; y positivo está ativo.

- MM_LOMETRIC cada unidade lógica é convertido em 0,1 milímetro. X positivo é para a direita; y positivo está ativo.

- MM_TEXT cada unidade lógica é convertido em pixel de 1 dispositivo. X positivo é para a direita; y positivo está inativo.

- MM_TWIPS cada unidade lógica é convertido em 1/20 de um ponto. (Como um ponto é 1/72 polegada, um twip é 1/1440 polegadas). X positivo é para a direita; y positivo está ativo.

### <a name="return-value"></a>Valor de retorno

O modo de mapeamento anterior.

### <a name="remarks"></a>Comentários

O modo de mapeamento define a unidade de medida usada para converter unidades lógicas em unidades de dispositivo; Ele também define a orientação do dispositivo x e y. GDI usa o modo de mapeamento para converter coordenadas lógicas em coordenadas de dispositivo apropriados. O modo MM_TEXT permite que os aplicativos trabalhem em pixels do dispositivo, onde 1 unidade é igual a 1 pixel. O tamanho físico de um pixel varia de um dispositivo para o dispositivo.

Os modos de MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC e MM_TWIPS são úteis para aplicativos que devem desenhar em unidades fisicamente significativas (como polegadas ou milímetros). O modo MM_ISOTROPIC garante uma taxa de proporção de 1:1, que é útil quando é importante preservar a forma exata de uma imagem. O modo MM_ANISOTROPIC permite que as coordenadas x e y a ser ajustada de forma independente.

> [!NOTE]
>  Se você chamar [SetLayout](#setlayout) para alterar o DC (contexto de dispositivo) para o layout da direita para esquerda, `SetLayout` automaticamente altera o modo de mapeamento para MM_ISOTROPIC.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

Altera o método usado pelo mapeador de fonte ao converter uma fonte lógica para uma fonte física.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Parâmetros

*dwFlag*<br/>
Especifica se o mapeador de fonte tenta corresponder a altura de aspecto da fonte e a largura para o dispositivo. Quando esse valor é ASPECT_FILTERING, o mapeador seleciona apenas fontes cujo aspecto de x e y aspecto corresponderem exatamente do dispositivo especificado.

### <a name="return-value"></a>Valor de retorno

O valor anterior do sinalizador mapeador de fonte.

### <a name="remarks"></a>Comentários

Um aplicativo pode usar `SetMapperFlags` para fazer com que o mapeador de fonte tentar escolher apenas uma fonte física que corresponde exatamente a taxa de proporção do dispositivo especificado.

Um aplicativo que usa fontes de varredura só pode usar o `SetMapperFlags` função para garantir que a fonte selecionada pelo mapeador de fonte é mais atraente e legível no dispositivo especificado. Os aplicativos que usam as fontes (TrueType) escalonáveis normalmente não usam `SetMapperFlags`.

Se nenhuma fonte física tiver uma taxa de proporção que corresponda à especificação na fonte lógica, GDI escolhe uma nova taxa de proporção e seleciona uma fonte que corresponde a essa nova taxa de proporção.

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

Define o limite para o comprimento de esquadrias para o contexto de dispositivo.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Parâmetros

*fMiterLimit*<br/>
Especifica o novo limite de Malhete para o contexto de dispositivo.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O comprimento do Malhete é definido como a distância entre a interseção das paredes dentro da junção de linha e a interseção das paredes linha na parte externa da junção. O limite de Malhete é a taxa máxima permitida de comprimento do Malhete e à largura da linha. O limite de Malhete padrão é 10.0.

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

Chame essa função de membro para definir o contexto de dispositivo de saída, `m_hDC`.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Parâmetros

*hDC*<br/>
Um contexto de dispositivo do Windows.

### <a name="remarks"></a>Comentários

Essa função de membro só pode ser chamada quando um contexto de dispositivo ainda não foi anexado para o `CDC` objeto. Essa função membro define `m_hDC` mas não anexa o contexto de dispositivo para o `CDC` objeto.

##  <a name="setpixel"></a>  CDC::SetPixel

Define o pixel no ponto especificado para a aproximação mais próxima da cor especificada por *crColor*.

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto a ser definido.

*y*<br/>
Especifica a coordenada y lógica do ponto a ser definido.

*crColor*<br/>
Um valor de RGB COLORREF que especifica a cor usada para pintar o ponto. Ver [COLORREF](/windows/desktop/gdi/colorref) no SDK do Windows para obter uma descrição desse valor.

*point*<br/>
Especifica a lógica coordenadas x e y-do ponto a ser definido. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Um valor RGB da cor que o ponto de realmente é pintado. Esse valor pode ser diferente do especificado pelo *crColor* se uma aproximação dessa cor é usada. Se a função falhar (se o ponto está fora da região de recorte), o valor de retorno é -1.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte. Se o ponto não estiver na região de recorte, a função não faz nada.

Nem todos os dispositivos oferecem suporte à função `SetPixel`. Para determinar se um dispositivo dá suporte à `SetPixel`, chame o `GetDeviceCaps` membro de função com o índice RASTERCAPS e verifique o valor retornado para o sinalizador RC_BITBLT.

##  <a name="setpixelv"></a>  CDC::SetPixelV

Define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x, em unidades lógicas, do ponto a ser definido.

*y*<br/>
Especifica a coordenada y, em unidades lógicas, do ponto a ser definido.

*crColor*<br/>
Especifica a cor a ser usado para pintar o ponto.

*point*<br/>
Especifica a lógica coordenadas x e y-do ponto a ser definido. Você pode transmitir uma [ponto](/windows/desktop/api/windef/ns-windef-tagpoint) estrutura de dados ou uma [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O ponto deve estar na região de recorte e a parte visível da superfície do dispositivo. Nem todos os dispositivos dão suporte a função de membro. Para obter mais informações, consulte o recurso RC_BITBLT no `CDC::GetDeviceCaps` função de membro. `SetPixelV` é mais rápido que `SetPixel` porque ele não precisa retornar o valor de cor do ponto em que realmente é pintado.

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

Define o modo de preenchimento de polígono.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Parâmetros

*nPolyFillMode*<br/>
Especifica o novo modo de preenchimento. Esse valor pode ser CONTORNO ou alternativo. O modo padrão definido no Windows é uma alternativa.

### <a name="return-value"></a>Valor de retorno

O modo de preenchimento anterior, se for bem-sucedido; Caso contrário, 0.

### <a name="remarks"></a>Comentários

Quando o modo de preenchimento de polígono é alternativo, o sistema preenche a área entre os lados de polígono ímpares e pares em cada linha de verificação. Ou seja, o sistema preenche a área entre o lado do primeiro e segundo, entre o lado de terceiro e quarto e assim por diante. Esse modo é o padrão.

Quando o modo de preenchimento de polígono é ENROLAMENTO, o sistema usa a direção na qual uma figura foi desenhada para determinar se uma área de preenchimento. Cada segmento de linha em um polígono é desenhado no sentido horário ou anti-horário. Sempre que uma linha imaginária extraída de uma área fechada para fora de uma figura passa por um segmento de linha no sentido horário, uma contagem é incrementada. Quando a linha passa por um segmento de linha no sentido anti-horário, a contagem é diminuída. A área é preenchida se a contagem for diferente de zero quando a linha alcança a parte externa da figura.

##  <a name="setrop2"></a>  CDC::SetROP2

Define o modo de desenho atual.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Parâmetros

*nDrawMode*<br/>
Especifica o novo modo de desenho. Ele pode ser qualquer um dos seguintes valores:

- É sempre R2_BLACK Pixel preto.

- Pixel R2_WHITE sempre é branco.

- Pixel R2_NOP permanece inalterado.

- Pixel R2_NOT é o inverso da cor da tela.

- R2_COPYPEN Pixel é a cor da caneta.

- Pixel R2_NOTCOPYPEN é o inverso da cor da caneta.

- R2_MERGEPENNOT Pixel é uma combinação da cor da caneta e o inverso da cor da tela (pixel final = (não pixels da tela) ou de caneta).

- R2_MASKPENNOT Pixel é uma combinação das cores comuns para a caneta e o inverso da tela (pixel final = (não pixels da tela) e de caneta).

- R2_MERGENOTPEN Pixel é uma combinação da cor da tela e o inverso da cor da caneta (final do pixel = (não caneta) ou tela pixel).

- R2_MASKNOTPEN Pixel é uma combinação das cores comuns para a tela e o inverso da caneta (final do pixel = (não caneta) e a tela de pixel).

- R2_MERGEPEN Pixel é uma combinação da cor da caneta e a cor da tela (pixel final = caneta pixels da tela de OR).

- Pixel R2_NOTMERGEPEN é o inverso da cor R2_MERGEPEN (final do pixel = não (pixels da tela de OR de caneta)).

- R2_MASKPEN Pixel é uma combinação de cores comuns para a caneta e a tela (pixel final = caneta AND pixel da tela).

- Pixel R2_NOTMASKPEN é o inverso da cor R2_MASKPEN (final do pixel = não (pixel de tela e de caneta)).

- R2_XORPEN Pixel é uma combinação das cores da caneta na tela, mas não em ambos (final do pixel = pixel de tela XOR de caneta).

- Pixel R2_NOTXORPEN é o inverso da cor R2_XORPEN (final do pixel = não (pixel de tela XOR de caneta)).

### <a name="return-value"></a>Valor de retorno

O modo de desenho anterior.

Ele pode ser qualquer um dos valores fornecidos no SDK do Windows.

### <a name="remarks"></a>Comentários

O modo de desenho Especifica como as cores da caneta e o interior de objetos preenchidos são combinadas com a cor já na superfície de exibição.

O modo de desenho é varredura somente para dispositivos; ele não se aplica a dispositivos de vetor. Modos de desenho são códigos de operação de varredura binária que representa todas as combinações possíveis de Boolianas de duas variáveis, usando os operadores binários AND, OR e XOR (OR exclusivo) e a operação unária não.

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

Define o modo de alongamento de bitmap para a `StretchBlt` função de membro.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Parâmetros

*nStretchMode*<br/>
Especifica o modo de alongamento. Ele pode ser qualquer um dos seguintes valores:

|Valor|Descrição|
|-----------|-----------------|
|BLACKONWHITE|Executa uma operação booliana e usando os valores de cor para os pixels serão eliminados e existentes. Se o bitmap é um bitmap monocromático, esse modo preserva pixels pretos às custas de pixels em branco.|
|COLORONCOLOR|Exclui os pixels. Esse modo exclui eliminadas todas as linhas de pixels sem tentar preservar suas informações.|
|MEIO-TOM|Mapeia os pixels do retângulo de origem em blocos de pixels no retângulo de destino. A cor média sobre o bloco de destino de pixels aproxima a cor de pixels de origem.|
||Depois de definir o modo de alongamento meio-tom, um aplicativo deve chamar a função Win32 [SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex) para definir a origem do pincel. Se ela não conseguir fazer isso, ocorre o desalinhamento de pincel.|
|STRETCH_ANDSCANS|**Windows 95/98**: Mesmo que BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: Mesmo que COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: Mesmo que o meio-tom.|
|STRETCH_ORSCANS|**Windows 95/98**: Mesmo que WHITEONBLACK|
|WHITEONBLACK|Executa uma operação booliana ou usando os valores de cor para os pixels serão eliminados e existentes. Se o bitmap é um bitmap monocromático, esse modo preserva pixels brancos às custas de pixels pretos.|

### <a name="return-value"></a>Valor de retorno

O modo de alongamento anterior. Ele pode ser STRETCH_ANDSCANS, STRETCH_DELETESCANS ou STRETCH_ORSCANS.

### <a name="remarks"></a>Comentários

O modo de alongamento de bitmap define como as informações são removidas do bitmaps que são compactadas usando a função.

Os modos de BLACKONWHITE (STRETCH_ANDSCANS) e WHITEONBLACK (STRETCH_ORSCANS) normalmente são usados para preservar os pixels do primeiro plano em bitmaps monocromático. O modo de COLORONCOLOR (STRETCH_DELETESCANS) normalmente é usado para preservar a cor em cor bitmaps.

O modo de meio-tom requer mais processamento da imagem de origem do que os outros três modos; ele é mais lento do que os outros, mas produz as imagens de qualidade superiores. Observe também que `SetBrushOrgEx` deve ser chamado depois de definir o modo de meio-tom para evitar o desalinhamento de pincel.

Modos de alongamento adicionais também podem estar disponíveis dependendo dos recursos do driver de dispositivo.

##  <a name="settextalign"></a>  CDC::SetTextAlign

Define os sinalizadores de alinhamento de texto.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Parâmetros

*nFlags*<br/>
Especifica os sinalizadores de alinhamento de texto. Os sinalizadores de especificam a relação entre um ponto e um retângulo que delimita o texto. O ponto de pode ser coordenadas especificadas por uma função de saída de texto ou a posição atual. O retângulo que limita o texto é definido pelas células adjacentes de caractere na cadeia de texto. O *nFlags* parâmetro pode ser um ou mais sinalizadores de três categorias a seguir. Escolha apenas um sinalizador de cada categoria. A primeira categoria afeta o alinhamento do texto na direção x:

- TA_CENTER alinha o ponto com o centro horizontal do retângulo delimitador.

- TA_LEFT alinha o ponto com o lado esquerdo do retângulo delimitador. Essa é a configuração padrão.

- TA_RIGHT alinha o ponto ao lado direito do retângulo delimitador.

A segunda categoria afeta o alinhamento do texto na direção y:

- TA_BASELINE alinha o ponto com a linha de base da fonte escolhida.

- TA_BOTTOM alinha o ponto na parte inferior do retângulo delimitador.

- TA_TOP alinha o ponto com a parte superior do retângulo delimitador. Essa é a configuração padrão.

A terceira categoria determina se a posição atual é atualizada quando o texto foi escrito:

- TA_NOUPDATECP não atualiza a posição atual após cada chamada para uma função de saída de texto. Essa é a configuração padrão.

- Atualizações TA_UPDATECP a atual posição x após cada chamada para uma função de saída de texto. A nova posição é no lado direito do retângulo delimitador do texto. Quando esse sinalizador estiver definido, as coordenadas especificadas em chamadas para o `TextOut` função de membro são ignorados.

### <a name="return-value"></a>Valor de retorno

A alinhamento do texto configuração anterior, se for bem-sucedido. O byte de ordem inferior contém a configuração horizontal e o byte de ordem superior contém a definição vertical; Caso contrário, 0.

### <a name="remarks"></a>Comentários

O `TextOut` e `ExtTextOut` funções de membro para usar esses sinalizadores ao posicionar uma cadeia de caracteres de texto em um dispositivo ou a exibição. Os sinalizadores de especificam a relação entre um ponto específico e um retângulo que delimita o texto. As coordenadas desse ponto são passadas como parâmetros para o `TextOut` função de membro. O retângulo que limita o texto é formado pelas células adjacentes de caractere na cadeia de texto.

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

Define a quantidade de espaçamento intercharacter.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Parâmetros

*nCharExtra*<br/>
Especifica a quantidade de espaço extra (em unidades lógicas) para ser adicionado a cada caractere. Se o modo de mapeamento atual não for `MM_TEXT`, *nCharExtra* é transformado e arredondado para o pixel mais próximo.

### <a name="return-value"></a>Valor de retorno

A quantidade de espaçamento intercharacter anterior.

### <a name="remarks"></a>Comentários

GDI adiciona esse espaçamento para cada caractere, incluindo caracteres de quebra, ao gravar uma linha de texto para o contexto de dispositivo. O valor padrão para a quantidade de espaçamento intercharacter é 0.

##  <a name="settextcolor"></a>  CDC::SetTextColor

Define a cor do texto com a cor especificada.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Parâmetros

*crColor*<br/>
Especifica a cor do texto como um valor de cor RGB.

### <a name="return-value"></a>Valor de retorno

Um valor RGB para a cor do texto anterior.

### <a name="remarks"></a>Comentários

O sistema usará essa cor do texto ao gravar o texto para este contexto de dispositivo e também quando convertendo bitmaps entre cores e contextos de dispositivo monocromático.

Se o dispositivo não pode representar a cor especificada, o sistema define a cor do texto para a cor mais próxima de física. A cor do plano de fundo para um caractere for especificada o `SetBkColor` e `SetBkMode` funções de membro.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

##  <a name="settextjustification"></a>  CDC::SetTextJustification

Adiciona um espaço para os caracteres de quebra em uma cadeia de caracteres.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Parâmetros

*nBreakExtra*<br/>
Especifica o total de espaço extra a ser adicionado à linha de texto (em unidades lógicas). Se o modo de mapeamento atual não for `MM_TEXT`, o valor fornecido por esse parâmetro é convertido para o modo de mapeamento atual e arredondado para a unidade mais próxima do dispositivo.

*nBreakCount*<br/>
Especifica o número de caracteres de quebra na linha.

### <a name="return-value"></a>Valor de retorno

1 se a função for bem-sucedida; Caso contrário, 0.

### <a name="remarks"></a>Comentários

Um aplicativo pode usar o `GetTextMetrics` caractere de quebra de funções de membro para recuperar uma fonte.

Após o `SetTextJustification` função de membro é chamado, uma chamada para uma função de saída de texto (como `TextOut`) distribui o espaço extra especificado uniformemente entre o número especificado de caracteres de quebra. O caractere de quebra geralmente é o caractere de espaço (ASCII 32), mas pode ser definido por uma fonte como qualquer outro caractere.

A função de membro `GetTextExtent` normalmente é usado com `SetTextJustification`. `GetTextExtent` calcula a largura de uma determinada linha antes de alinhamento. Um aplicativo pode determinar a quantidade de espaço para especificar na *nBreakExtra* parâmetro subtraindo o valor retornado por `GetTextExtent` da largura da cadeia de caracteres após o alinhamento.

O `SetTextJustification` função pode ser usada para alinhar uma linha que contém várias execuções em diferentes fontes. Nesse caso, a linha deve ser criada por etapas alinhando e escrever cada execução separadamente.

Como erros de arredondamento podem ocorrer durante o alinhamento, o sistema mantém um termo de erro em execução que define o erro atual. Quando uma linha que contém várias execuções, o alinhamento `GetTextExtent` usa automaticamente esse termo de erro quando ele calcula a extensão da próxima execução. Isso permite que a função de saída de texto para o erro se fundam com a nova execução.

Depois de cada linha tem sido alinhada, esse termo de erro deve ser limpo para impedir que ele está sendo incorporadas a próxima linha. O termo pode ser desmarcado chamando `SetTextJustification` com *nBreakExtra* definido como 0.

##  <a name="setviewportext"></a>  CDC::SetViewportExt

Define as extensões x e y do visor do contexto do dispositivo.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*cx*<br/>
Especifica a extensão de x do visor (em unidades de dispositivo).

*cy*<br/>
Especifica a extensão de y do visor (em unidades de dispositivo).

*size*<br/>
Especifica as extensões x e y do visor (em unidades de dispositivo).

### <a name="return-value"></a>Valor de retorno

As extensões anteriores do visor como uma [CSize](../../atl-mfc-shared/reference/csize-class.md) objeto. Quando ocorre um erro, as coordenadas x e y de retornado `CSize` do objeto são definidos como 0.

### <a name="remarks"></a>Comentários

O visor, juntamente com a janela do contexto de dispositivo, define como a GDI mapeia pontos no sistema de coordenadas lógico para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, elas definem como a GDI converte coordenadas lógicas em coordenadas do dispositivo.

Quando os seguintes modos de mapeamento são definidos, chamadas para `SetWindowExt` e `SetViewportExt` são ignorados:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

Quando o modo MM_ISOTROPIC estiver definido, um aplicativo deve chamar o `SetWindowExt` função de membro antes de chamar `SetViewportExt`.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

Define a origem do visor do contexto do dispositivo.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades de dispositivo) da origem do visor. O valor deve ser dentro do intervalo de sistema de coordenadas do dispositivo.

*y*<br/>
Especifica a coordenada y (em unidades de dispositivo) da origem do visor. O valor deve ser dentro do intervalo de sistema de coordenadas do dispositivo.

*point*<br/>
Especifica a origem do visor. Os valores devem ser dentro do intervalo de sistema de coordenadas do dispositivo. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior do visor (nas coordenadas do dispositivo) como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

O visor, juntamente com a janela do contexto de dispositivo, define como a GDI mapeia pontos no sistema de coordenadas lógico para pontos no sistema de coordenadas do dispositivo real. Em outras palavras, elas definem como a GDI converte coordenadas lógicas em coordenadas do dispositivo.

A origem do visor marca o ponto no sistema de coordenadas de dispositivo para o qual GDI mapeia a origem de janela, um ponto no sistema de coordenadas lógico especificado pelo `SetWindowOrg` função de membro. GDI mapeia todos os outros pontos, seguindo o mesmo processo necessário para a origem de janela para a origem do visor do mapa. Por exemplo, todos os pontos em um círculo em torno do ponto na origem janela será em um círculo em torno do ponto em que a origem do visor. Da mesma forma, todos os pontos em uma linha que passa pela origem janela será em uma linha que passa pela origem do visor.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindowext"></a>  CDC::SetWindowExt

Define as extensões x e y da janela associada ao contexto de dispositivo.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Parâmetros

*cx*<br/>
Especifica a extensão x (em unidades lógicas) da janela.

*cy*<br/>
Especifica a extensão y (em unidades lógicas) da janela.

*size*<br/>
Especifica a x - e y-extensões (em unidades lógicas) da janela.

### <a name="return-value"></a>Valor de retorno

As extensões anteriores da janela (em unidades lógicas) como um `CSize` objeto. Se ocorrer um erro, as coordenadas x e y de retornado `CSize` do objeto são definidos como 0.

### <a name="remarks"></a>Comentários

A janela, bem como o visor do contexto de dispositivo, define como a GDI mapeia pontos no sistema de coordenadas lógico para pontos em que o sistema de coordenadas do dispositivo.

Quando os seguintes modos de mapeamento são definidos, chamadas para `SetWindowExt` e `SetViewportExt` funções são ignoradas:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

Quando o modo MM_ISOTROPIC estiver definido, um aplicativo deve chamar o `SetWindowExt` função de membro antes de chamar `SetViewportExt`.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

Define a origem da janela do contexto do dispositivo.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica da origem da nova da janela.

*y*<br/>
Especifica a coordenada y lógica da origem da nova da janela.

*point*<br/>
Especifica as coordenadas lógicas da origem da nova da janela. Você pode transmitir uma `POINT` estrutura ou um `CPoint` objeto para esse parâmetro.

### <a name="return-value"></a>Valor de retorno

A origem anterior da janela como um `CPoint` objeto.

### <a name="remarks"></a>Comentários

A janela, bem como o visor do contexto de dispositivo, define como a GDI mapeia pontos no sistema de coordenadas lógico para pontos em que o sistema de coordenadas do dispositivo.

A origem de janela marca o ponto no sistema de coordenadas lógico da qual GDI mapeia a origem do visor, um ponto no sistema de coordenadas de dispositivo especificado pelo `SetWindowOrg` função. GDI mapeia todos os outros pontos, seguindo o mesmo processo necessário para a origem de janela para a origem do visor do mapa. Por exemplo, todos os pontos em um círculo em torno do ponto na origem janela será em um círculo em torno do ponto em que a origem do visor. Da mesma forma, todos os pontos em uma linha que passa pela origem janela será em uma linha que passa pela origem do visor.

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

Define uma transformação linear bidimensional entre espaço de mundo e página para o contexto de dispositivo especificado. Essa transformação pode ser usada para dimensionar, girar, distorcer ou converter a saída de gráficos.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Parâmetros

*rXform*<br/>
Referência a um [XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform) estrutura que contém os dados de transformação.

### <a name="return-value"></a>Valor de retorno

Retorna um valor diferente de zero em caso de sucesso.

Retorna 0 em caso de falha.

Para obter outras informações de erro, chame [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360).

### <a name="remarks"></a>Comentários

Esse método encapsula a função do Windows GDI [SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform).

##  <a name="startdoc"></a>  CDC::StartDoc

Informa o driver de dispositivo que está iniciando um novo trabalho de impressão e que todos os próximos `StartPage` e `EndPage` chamadas devem estar no spool sob o mesmo trabalho até que um `EndDoc` chamada ocorre.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Parâmetros

*lpDocInfo*<br/>
Aponta para um [DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa) estrutura que contém o nome do arquivo de documento e o nome do arquivo de saída.

*lpszDocName*<br/>
Ponteiro para uma cadeia de caracteres que contém o nome do arquivo de documento.

### <a name="return-value"></a>Valor de retorno

Se a função for bem-sucedida, o valor de retorno é maior que zero. Esse valor é o identificador do trabalho de impressão para o documento.

Se a função falhar, o valor de retorno é menor que ou igual a zero.

### <a name="remarks"></a>Comentários

Isso garante que mais de uma página de documentos não serão ser intercalados com outros trabalhos.

Para Windows versões 3.1 e posteriores, essa função substitui o escape de impressora STARTDOC. Usando essa função garante que os documentos que contenham mais de uma página não são intercalados com outros trabalhos de impressão.

`StartDoc` não deve ser usado dentro de metarquivos.

### <a name="example"></a>Exemplo

Este fragmento de código obtém a impressora padrão, abre um trabalho de impressão e coloca no spool uma página com "Olá, mundo!" nele. Como o texto a ser impresso por este código não é dimensionado para unidades lógicas da impressora, o texto de saída pode ser em tais letras que o resultado é ilegível. O CDC dimensionamento funções, tais como `SetMapMode`, `SetViewportOrg`, e `SetWindowExt`, pode ser usado para corrigir a colocação em escala.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

Chame essa função de membro para preparar o driver de impressora para receber dados.

```
int StartPage();
```

### <a name="return-value"></a>Valor de retorno

Maior que ou igual a 0 se a função for bem-sucedida, ou um valor negativo se ocorreu um erro.

### <a name="remarks"></a>Comentários

`StartPage` substitui os escapes NEWFRAME e BANDINFO.

Para obter uma visão geral da sequência de chamadas de impressão, consulte o [StartDoc](#startdoc) função de membro.

O sistema desabilita a `ResetDC` função de membro entre as chamadas para `StartPage` e `EndPage`.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC::StartDoc](#startdoc).

##  <a name="stretchblt"></a>  CDC::StretchBlt

Copia um bitmap de um retângulo de origem em um retângulo de destino, alongando-o ou compactando-o, se necessário, para ajustá-lo às dimensões do retângulo de destino.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*y*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de destino.

*nWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de destino.

*nHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de destino.

*pSrcDC*<br/>
Especifica o contexto do dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y (em unidades lógicas) do canto esquerdo superior do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura (em unidades lógicas) do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura (em unidades lógicas) do retângulo de origem.

*dwRop*<br/>
Especifica a operação de varredura a ser executada. Os códigos da operação de varredura definem como a GDI combina cores nas operações de saída que envolvem um pincel, um possível bitmap de origem e um bitmap de destino. Esse parâmetro pode ser um dos seguintes valores:

- {1&gt;BLACKNESS&lt;1 transforma de que toda a saída preto.

- {1&gt;DSTINVERT&lt;1 inverte o bitmap de destino.

- {1&gt;MERGECOPY&lt;1 combina o padrão e o bitmap de origem usando o operador AND booliano.

- {1&gt;MERGEPAINT&lt;1 combina o bitmap de origem invertido com o bitmap de destino usando o operador OR booliano.

- {1&gt;NOTSRCCOPY&lt;1 copia o bitmap de origem invertido no destino.

- {1&gt;NOTSRCERASE&lt;1 inverte o resultado da combinação de bitmaps de destino e origem usando o operador OR booliano.

- {1&gt;PATCOPY&lt;1 copia o padrão para o bitmap de destino.

- {1&gt;PATINVERT&lt;1 combina o bitmap de destino com o padrão usando o operador XOR booliano.

- {1&gt;PATPAINT&lt;1 combina o bitmap de origem invertido com o padrão usando o operador OR booliano. Combina o resultado dessa operação com o bitmap de destino usando o operador OR booliano.

- {1&gt;SRCAND&lt;1 combina pixels dos bitmaps de destino e origem usando o operador AND booliano.

- {1&gt;SRCCOPY&lt;1 copia o bitmap de origem para o bitmap de destino.

- {1&gt;SRCERASE&lt;1 inverte o bitmap de destino e combina o resultado com o bitmap de origem usando o operador AND booliano.

- {1&gt;SRCINVERT&lt;1 combina pixels dos bitmaps de destino e origem usando o operador XOR booliano.

- {1&gt;SRCPAINT&lt;1 combina pixels dos bitmaps de destino e origem usando o operador OR booliano.

- {1&gt;WHITENESS&lt;1 transforma de que toda a saída em branco.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se o bitmap for desenhado; caso contrário, 0.

### <a name="remarks"></a>Comentários

A função usa o modo de alongamento do contexto do dispositivo de destino (definido por `SetStretchBltMode`) para determinar como alongar ou compactar o bitmap.

O `StretchBlt` função move o bitmap do dispositivo de origem fornecido pelo *pSrcDC* para o dispositivo de destino representado pelo objeto de contexto de dispositivo cuja função de membro está sendo chamada. O *xSrc*, *ySrc*, *nSrcWidth*, e *nSrcHeight* parâmetros definem o canto superior esquerdo e as dimensões do retângulo de origem . O *x*, *y*, *nWidth*, e *nHeight* parâmetros fornecem o canto superior esquerdo e as dimensões do retângulo de destino. A operação de varredura especificada por *dwRop* define como o bitmap de origem e os bits já no dispositivo de destino são combinados.

O `StretchBlt` função cria uma imagem espelhada de um bitmap se os sinais do *nSrcWidth* e *nWidth* ou *nSrcHeight* e *nHeight* diferem de parâmetros. Se *nSrcWidth* e *nWidth* tiverem sinais diferentes, a função cria uma imagem espelhada do bitmap ao longo do eixo x. Se *nSrcHeight* e *nHeight* tiverem sinais diferentes, a função cria uma imagem espelhada do bitmap ao longo do eixo y.

A função `StretchBlt` alonga ou compacta o bitmap de origem na memória e copia o resultado no destino. Se um padrão deve ser mesclado com o resultado, ele não será mesclado até que o bitmap de origem alongado seja copiado no destino. Se um pincel for usado, é o pincel selecionado no contexto do dispositivo de destino. As coordenadas de destino são transformadas de acordo com o contexto do dispositivo de destino; as coordenadas de origem são transformadas de acordo com o contexto do dispositivo de origem.

Se os bitmaps de destino, origem e padrão não tiverem o mesmo formato de cor, `StretchBlt` converterá os bitmaps de origem e padrão para correspondência com os bitmaps de destino. As cores do primeiro plano e do plano de fundo do contexto do dispositivo de destino são usadas na conversão.

Se `StretchBlt` precisar converter um bitmap monocromático em colorido, ele definirá bits brancos (1) para a cor do plano de fundo e bits pretos (0) para a cor do primeiro plano. Para converter o colorido em monocromático, ele define pixels que correspondam à cor do plano de fundo para branco (1) e define todos os outros pixels para preto (0). As cores do primeiro plano e do plano de fundo do contexto do dispositivo com cor são usadas.

Nem todos os dispositivos oferecem suporte à função `StretchBlt`. Para determinar se um dispositivo dá suporte à `StretchBlt`, chame o `GetDeviceCaps` membro de função com o índice RASTERCAPS e verifique o valor retornado para o sinalizador RC_STRETCHBLT.

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

Fecha as figuras abertas em um caminho, traçados a estrutura de tópicos do caminho usando a caneta atual e preenche o interior usando o pincel atual.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado. O `StrokeAndFillPath` função de membro tem o mesmo efeito que fechar todas as figuras abertas no caminho e traçar e preenchendo o caminho separadamente, exceto que a região preenchida não se sobrepõem o mesmo se a região traçadas a caneta é grande.

##  <a name="strokepath"></a>  CDC::StrokePath

Renderiza o caminho especificado usando a caneta atual.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

O contexto do dispositivo deve conter um caminho fechado.

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

Chame essa função de membro para gravar uma cadeia de caracteres no local especificado, a expansão de guias para os valores especificados na matriz de posições de parada de tabulação.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto inicial da cadeia de caracteres.

*y*<br/>
Especifica a coordenada y lógica do ponto inicial da cadeia de caracteres.

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhado. Você pode passar um ponteiro para uma matriz de caracteres ou um [CString](../../atl-mfc-shared/reference/cstringt-class.md) objeto para esse parâmetro.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres. Se *nCount* é -1, o comprimento será calculado.

*nTabPositions*<br/>
Especifica o número de valores na matriz de posições de parada de tabulação.

*lpnTabStopPositions*<br/>
Aponta para uma matriz que contém as posições de parada de tabulação (em unidades lógicas). As paradas de tabulação devem ser classificadas em ordem; crescente o menor valor de x deve ser o primeiro item na matriz.

*nTabOrigin*<br/>
Especifica a coordenada x da posição inicial da qual as guias são expandidas (em unidades lógicas).

*str*<br/>
Um `CString` objeto que contém os caracteres especificados.

### <a name="return-value"></a>Valor de retorno

As dimensões da cadeia de caracteres (em unidades lógicas) como um `CSize` objeto.

### <a name="remarks"></a>Comentários

O texto é escrito na fonte selecionada no momento. Se *nTabPositions* é 0 e *lpnTabStopPositions* for NULL, as guias são expandidas para oito vezes a média largura do caractere.

Se *nTabPositions* é 1, a guia paradas são separadas pela distância especificada pelo valor da primeira a *lpnTabStopPositions* matriz. Se o *lpnTabStopPositions* matriz contém mais de um valor, uma parada de tabulação é definida para cada valor na matriz, até o número especificado por *nTabPositions*. O *nTabOrigin* parâmetro permite que um aplicativo chamar o `TabbedTextOut` função várias vezes para uma única linha. Se o aplicativo chama a função mais de uma vez com o *nTabOrigin* definido como o mesmo valor de cada vez, a função expande todas as guias em relação à posição especificada por *nTabOrigin*.

Por padrão, a posição atual não é usada nem atualizada pela função. Se um aplicativo precisar atualizar a posição atual quando ela chama a função, o aplicativo pode chamar o [SetTextAlign](#settextalign) função de membro com *nFlags* definido como TA_UPDATECP. Quando esse sinalizador estiver definido, o Windows ignora a *x* e *y* parâmetros em chamadas subsequentes para `TabbedTextOut`, usando a posição atual em vez disso.

##  <a name="textout"></a>  CDC::TextOut

Grava uma cadeia de caracteres no local especificado usando a fonte selecionada no momento.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Parâmetros

*x*<br/>
Especifica a coordenada x lógica do ponto de partida do texto.

*y*<br/>
Especifica a coordenada y lógica do ponto de partida do texto.

*lpszString*<br/>
Aponta para a cadeia de caracteres a ser desenhada.

*nCount*<br/>
Especifica o número de caracteres na cadeia de caracteres.

*str*<br/>
Um objeto `CString` que contém os caracteres a serem desenhados.

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

As origens do caractere estão no canto superior esquerdo da célula do caractere. Por padrão, a posição atual não é usada nem atualizada pela função.

Se um aplicativo precisar atualizar a posição atual quando ele chama `TextOut`, o aplicativo pode chamar o `SetTextAlign` função de membro com *nFlags* definido como TA_UPDATECP. Quando esse sinalizador estiver definido, o Windows ignora a *x* e *y* parâmetros em chamadas subsequentes para `TextOut`, usando a posição atual em vez disso.

### <a name="example"></a>Exemplo

  Veja o exemplo de [CDC:: beginpath](#beginpath).

##  <a name="transparentblt"></a>  CDC::TransparentBlt

Chame essa função de membro para transferir um bloco de bits dos dados de cor, que corresponde a um retângulo de pixels do contexto do dispositivo de origem especificado em um contexto de dispositivo de destino.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Parâmetros

*xDest*<br/>
Especifica a coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*yDest*<br/>
Especifica a coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.

*nDestWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de destino.

*nDestHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de destino.

*pSrcDC*<br/>
Ponteiro para o contexto de dispositivo de origem.

*xSrc*<br/>
Especifica a coordenada x, em unidades lógicas, do retângulo de origem.

*ySrc*<br/>
Especifica a coordenada y, em unidades lógicas, do retângulo de origem.

*nSrcWidth*<br/>
Especifica a largura, em unidades lógicas, do retângulo de origem.

*nSrcHeight*<br/>
Especifica a altura, em unidades lógicas, do retângulo de origem.

*clrTransparent*<br/>
A cor RGB no bitmap de origem a ser tratada como transparente.

### <a name="return-value"></a>Valor de retorno

VERDADEIRO se bem-sucedido; Caso contrário, FALSE.

### <a name="remarks"></a>Comentários

`TransparentBlt` permite a transparência. ou seja, a cor RGB indicado por *clrTransparent* é renderizado transparente para a transferência.

Para obter mais informações, consulte [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) no SDK do Windows.

##  <a name="updatecolors"></a>  CDC::UpdateColors

Atualizações de área de cliente do contexto do dispositivo combinando atual cores na área de cliente para a paleta do sistema em uma base de pixel por pixel.

```
void UpdateColors();
```

### <a name="remarks"></a>Comentários

Uma janela inativa com uma paleta lógica realizada pode chamar `UpdateColors` como uma alternativa para redesenhar sua área de cliente quando a paleta do sistema é alterado.

Para obter mais informações sobre como usar paletas de cores, consulte [UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) no SDK do Windows.

O `UpdateColors` função de membro normalmente atualiza uma área de cliente mais rápido do que o redesenho da área. No entanto, como a função executa a conversão de cores com base na cor de cada pixel antes que a paleta do sistema é alterada, cada chamada para essa função resulta na perda de precisão de algumas cores.

##  <a name="widenpath"></a>  CDC::WidenPath

Redefine o caminho atual como a área que deve ser pintada se o caminho foram traçado usando a caneta selecionada atualmente no contexto de dispositivo.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Valor de retorno

Diferente de zero se a função for bem-sucedida; caso contrário, 0.

### <a name="remarks"></a>Comentários

Essa função é bem-sucedido somente se a caneta atual for uma caneta geométrica criada pela segunda versão do `CreatePen` função de membro, ou se a caneta for criada com a primeira versão do `CreatePen` e tem uma largura, em unidades de dispositivo, do maior que 1. O contexto do dispositivo deve conter um caminho fechado. Qualquer curvas Bzier no caminho são convertidos em sequências de linhas retas aproximar as curvas largo. Como tal, não há curvas Bzier permanecem no caminho após `WidenPath` é chamado.

## <a name="see-also"></a>Consulte também

[Classe CObject](../../mfc/reference/cobject-class.md)<br/>
[Gráfico da hierarquia](../../mfc/hierarchy-chart.md)<br/>
[Classe CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Classe CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Classe CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Classe CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
